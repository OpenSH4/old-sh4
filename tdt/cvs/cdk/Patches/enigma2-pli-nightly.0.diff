
@@ -245,6 +282,10 @@
 lib/python/Plugins/SystemPlugins/Videomode/meta/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/meta/Makefile
+lib/python/Plugins/Extensions/TopfieldVFD/Makefile
+lib/python/Plugins/Extensions/CuberevoVFD/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile
 lib/python/Tools/Makefile
 po/Makefile
 main/Makefile
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/base/eptrlist.h enigma2-nightly/lib/base/eptrlist.h
--- enigma2-nightly.org/lib/base/eptrlist.h	2013-01-31 12:39:33.616182807 +0100
+++ enigma2-nightly/lib/base/eptrlist.h	2013-01-31 12:39:33.984182822 +0100
@@ -175,7 +175,7 @@
 	{
 		// added a new item to the list... in order
 		// returns a iterator to the new item
-		return insert( std::lower_bound( std::list<T*>::begin(), std::list<T*>::end(), e, less()), e );
+		return this->insert( std::lower_bound( std::list<T*>::begin(), std::list<T*>::end(), e, less()), e );
 	}
 
 };
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/base/etpm.cpp enigma2-nightly/lib/base/etpm.cpp
--- enigma2-nightly.org/lib/base/etpm.cpp	2013-01-31 12:39:33.616182807 +0100
+++ enigma2-nightly/lib/base/etpm.cpp	2013-01-31 12:39:33.984182822 +0100
@@ -6,14 +6,17 @@
 #include <string.h>
 #include <sys/un.h>
 #include <unistd.h>
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 #include <openssl/bn.h>
 #include <openssl/sha.h>
+#endif
 #include <lib/base/eerror.h>
 
 #include "etpm.h"
 
 eTPM::eTPM()
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	struct sockaddr_un addr;
 	unsigned char buf[8];
 	unsigned int tag;
@@ -53,6 +56,7 @@
 
 	parse_data(val, len);
 	free(val);
+#endif
 }
 
 eTPM::~eTPM()
@@ -63,6 +67,7 @@
 
 bool eTPM::send_cmd(enum tpmd_cmd cmd, const void *data, size_t len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[len + 4];
 
 	buf[0] = (cmd >> 8) & 0xff;
@@ -77,11 +82,13 @@
 		return false;
 	}
 
+#endif
 	return true;
 }
 
 void* eTPM::recv_cmd(unsigned int *tag, size_t *len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[4];
 	void *val;
 
@@ -111,10 +118,14 @@
 	}
 
 	return val;
+#else
+	return NULL;
+#endif
 }
 
 void eTPM::parse_data(const unsigned char *data, size_t datalen)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned int i;
 	unsigned int tag;
 	unsigned int len;
@@ -140,19 +151,23 @@
 			break;
 		}
 	}
+#endif
 }
 
 std::string eTPM::getCert(cert_type type)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (type == TPMD_DT_LEVEL2_CERT && level2_cert_read)
 		return std::string((char*)level2_cert, 210);
 	else if (type == TPMD_DT_LEVEL3_CERT && level3_cert_read)
 		return std::string((char*)level3_cert, 210);
+#endif
 	return "";
 }
 
 std::string eTPM::challenge(std::string rnd)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (rnd.length() == 8)
 	{
 		if (!send_cmd(TPMD_CMD_COMPUTE_SIGNATURE, rnd.c_str(), 8))
@@ -169,5 +184,6 @@
 		free(val);
 		return ret;
 	}
+#endif
 	return "";
 }

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/base/filepush.h enigma2-nightly/lib/base/filepush.h
--- enigma2-nightly.org/lib/base/filepush.h	2013-01-31 12:39:33.616182807 +0100
+++ enigma2-nightly/lib/base/filepush.h	2013-01-31 12:39:33.984182822 +0100
@@ -13,6 +13,10 @@
 public:
 	virtual void getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size)=0;
 	virtual ~iFilePushScatterGather() {}
+#if defined(__sh__)
+	//Changes in this file are cause e2 doesnt tell the player to play reverse
+	virtual int getSkipMode() = 0;
+#endif
 };
 
 class eFilePushThread: public eThread, public Object


diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/driver/vfd.cpp enigma2-nightly/lib/driver/vfd.cpp
--- enigma2-nightly.org/lib/driver/vfd.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/driver/vfd.cpp	2013-01-31 12:39:33.984182822 +0100
@@ -0,0 +1,529 @@
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include  <pthread.h>
+
+#include <lib/base/eerror.h>
+#include <lib/driver/vfd.h>
+
+#ifdef PLATFORM_TF7700
+#include "../../misc/tools/tffpctl/frontpanel.h"
+#endif
+
+#define VFD_DEVICE "/dev/vfd"
+#define VFDICONDISPLAYONOFF   0xc0425a0a
+#define VFDDISPLAYCHARS       0xc0425a00
+#define VFDBRIGHTNESS         0xc0425a03
+//light on off
+#define VFDDISPLAYWRITEONOFF  0xc0425a05
+
+bool startloop_running = false;
+static bool icon_onoff[32];
+static pthread_t thread_start_loop = 0;
+void * start_loop (void *arg);
+bool blocked = false;
+bool requested = false;
+bool VFD_CENTER = false;
+bool scoll_loop = false;
+int VFD_SCROLL = 1;
+
+char chars[64];
+char g_str[64];
+
+struct vfd_ioctl_data
+{
+	unsigned char start;
+	unsigned char data[64];
+	unsigned char length;
+};
+
+#ifdef PLATFORM_HS7810A
+	#define VFDLENGTH 4
+#elif defined PLATFORM_OCTAGON1008
+	#define VFDLENGTH 8
+#elif defined (PLATFORM_FORTIS_HDBOX) || defined(PLATFORM_ATEVIO7500)
+	#define VFDLENGTH 12
+#else
+	#define VFDLENGTH 16
+#endif
+
+evfd* evfd::instance = NULL;
+
+evfd* evfd::getInstance()
+{
+	if (instance == NULL)
+		instance = new evfd;
+	return instance;
+}
+
+evfd::evfd()
+{
+	file_vfd = 0;
+	memset ( chars, ' ', 63 );
+}
+
+void evfd::init()
+{
+	pthread_create (&thread_start_loop, NULL, &start_loop, NULL);
+	return;
+}
+
+evfd::~evfd()
+{
+	//close (file_vfd);
+}
+
+#ifdef PLATFORM_TF7700
+char * getProgress()
+{
+	int n;
+	static char progress[20] = "0";
+	int fd = open ("/proc/progress", O_RDONLY);
+
+	if (fd < 0)
+		return 0;
+
+	n = read(fd, progress, sizeof(progress));
+	close(fd);
+
+	if (n < 0)
+		n = 0;
+	else if((n > 1) && (progress[n-1] == 0xa))
+		n--;
+
+	progress[n] = 0;
+	return progress;
+}
+
+#define MAX_CHARS 8
+
+void * start_loop (void *arg)
+{
+	int fplarge = open ("/dev/fplarge", O_WRONLY);
+	int fpsmall = open ("/dev/fpsmall", O_WRONLY);
+	int fpc = open ("/dev/fpc", O_WRONLY);
+
+	if ((fplarge < 0) || (fpsmall < 0) || (fpc < 0))
+	{
+		printf("Failed opening devices (%d, %d, %d)\n", fplarge, fpsmall, fpc);
+		return NULL;
+	}
+
+	blocked = true;
+
+	// set scroll mode
+	//frontpanel_ioctl_scrollmode scrollMode = {2, 10, 15};
+	//ioctl(fpc, FRONTPANELSCROLLMODE, &scrollMode);
+
+	// display string
+	char str[] = "        SH4 Git ENIGMA2";
+	int length = strlen(str);
+	char dispData[MAX_CHARS + 1];
+	int offset = 0;
+	int i;
+
+	frontpanel_ioctl_icons icons = {0, 0, 0xf};
+
+	// start the display loop
+	char * progress = getProgress();
+	int index = 2;
+	while (!requested)
+	{
+		// display the CD segments
+		icons.Icons2 = (((1 << index) - 1)) & 0x1ffe;
+		ioctl(fpc, FRONTPANELICON, &icons);
+		index++;
+		if (index > 13)
+		{
+			index = 2;
+			icons.BlinkMode = (~icons.BlinkMode) & 0xf;
+		}
+
+		// display the visible part of the string
+		for (i = 0; i < MAX_CHARS; i++)
+		{
+			dispData[i] = str[(offset + i) % length];
+		}
+		offset++;
+		write(fplarge, dispData, sizeof(dispData));
+		usleep(200000);
+		if ((index % 4) == 0)
+		{
+			// display progress
+			progress = getProgress();
+			write(fpsmall, progress, strlen(progress) + 1);
+			if (strncmp("100", progress, 3) == 0)
+				break;
+		}
+	}
+	// clear all icons
+	frontpanel_ioctl_icons iconsOff = {0xffffffff, 0xffffffff, 0x0};
+	ioctl(fpc, FRONTPANELICON, &iconsOff);
+
+	// clear display
+	write(fpsmall, "    ", 5);
+	write(fplarge, "        ", MAX_CHARS);
+
+	close(fplarge);
+	close(fpsmall);
+	close(fpc);
+	blocked = false;
+
+	return NULL;
+}
+#else
+
+void * start_loop (void *arg)
+{
+	evfd vfd;
+	blocked = true;
+	//vfd.vfd_clear_icons();
+	vfd.vfd_write_string("SH4 Git ENIGMA2", true);
+	//run 2 times through all icons 
+	for (int vloop = 0; vloop < 128; vloop++)
+	{
+#if !defined(PLATFORM_FORTIS_HDBOX) && !defined(PLATFORM_OCTAGON1008) && !defined(PLATFORM_ATEVIO7500) && !defined(PLATFORM_CUBEREVO) && !defined(PLATFORM_CUBEREVO_MINI) && !defined(PLATFORM_CUBEREVO_MINI2) && !defined(PLATFORM_CUBEREVO_MINI_FTA) && !defined(PLATFORM_CUBEREVO_250HD) && !defined(PLATFORM_CUBEREVO_2000HD) && !defined(PLATFORM_CUBEREVO_9500HD) && !defined(PLATFORM_HS7810A)
+		if (vloop%2 == 1)
+		{
+			vfd.vfd_set_icon( (tvfd_icon) (((vloop%32)/2)%16), ICON_OFF, true);
+			//usleep(1000);
+			vfd.vfd_set_icon( (tvfd_icon) ((((vloop%32)/2)%16)+1), ICON_ON, true);
+		}
+#else
+		if (vloop%14 == 0 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 1 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 2 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 3 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 4 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 5 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 6 )
+			vfd.vfd_set_brightness(7);
+		else if (vloop%14 == 7 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 8 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 9 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 10 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 11 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 12 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 13 )
+			vfd.vfd_set_brightness(0);
+#endif
+		usleep(75000);
+	}
+	vfd.vfd_set_brightness(7);
+#if !defined(PLATFORM_FORTIS_HDBOX) && !defined(PLATFORM_OCTAGON1008) && !defined(PLATFORM_ATEVIO7500) && !defined(PLATFORM_CUBEREVO) && !defined(PLATFORM_CUBEREVO_MINI) && !defined(PLATFORM_CUBEREVO_MINI2) && !defined(PLATFORM_CUBEREVO_MINI_FTA) && !defined(PLATFORM_CUBEREVO_250HD) && !defined(PLATFORM_CUBEREVO_2000HD) && !defined(PLATFORM_CUBEREVO_9500HD) && !defined(PLATFORM_HS7810A)
+	//set all blocked icons
+	for (int id = 0x10; id < 0x20; id++)
+	{
+		vfd.vfd_set_icon((tvfd_icon)id, icon_onoff[id]);
+	}
+#endif
+	blocked = false;
+	return NULL;
+}
+#endif
+
+#if defined(PLATFORM_FORTIS_HDBOX) || defined(PLATFORM_OCTAGON1008) || defined(PLATFORM_ATEVIO7500) || defined(PLATFORM_CUBEREVO) || defined(PLATFORM_CUBEREVO_MINI) || defined(PLATFORM_CUBEREVO_MINI2) || defined(PLATFORM_CUBEREVO_MINI_FTA) || defined(PLATFORM_CUBEREVO_250HD) || defined(PLATFORM_CUBEREVO_2000HD) || defined(PLATFORM_CUBEREVO_9500HD) || defined(PLATFORM_HS7810A)
+void evfd::vfd_write_string_scrollText(char* text)
+{
+	return;
+}
+
+//we can not use a member function (vfd_write_string_scrollText) in pthread, so we use a second (same content) non member function (vfd_write_string_scrollText1)
+static void *vfd_write_string_scrollText1(void *arg)
+{
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+	bool scoll_loop = true;
+	char out[VFDLENGTH+1];
+	int i, len;
+	evfd vfd;
+	len = strlen((char *) g_str);
+	memset(out, 0, VFDLENGTH+1);
+	while (scoll_loop && (len > VFDLENGTH))
+	{
+		if (blocked)
+		{
+			usleep(250000);
+		}
+		else
+		{
+			scoll_loop = false;
+		}
+		for (i=0; i<=(len-VFDLENGTH); i++)
+		{
+			if (blocked)
+			{
+				memset(out, ' ', VFDLENGTH);
+				memcpy(out, g_str+i, VFDLENGTH);
+				vfd.vfd_write_string(out,true);
+				usleep(250000);
+			}
+			else
+			{
+				scoll_loop = false;
+				i = len-VFDLENGTH;
+			}
+		}
+		for (i=1; i < VFDLENGTH; i++)
+		{
+			if (blocked)
+			{
+				memset(out, ' ', VFDLENGTH);
+				memcpy(out, g_str+len+i-VFDLENGTH, VFDLENGTH-i);
+				vfd.vfd_write_string(out,true);
+				usleep(250000);
+			}
+			else
+			{
+				scoll_loop = false;
+				i = VFDLENGTH;
+			}
+		}
+		memcpy(out, g_str, VFDLENGTH);
+		vfd.vfd_write_string(out,true);
+		if (VFD_SCROLL != 2 || !blocked)
+			scoll_loop = false;
+	}
+	blocked = false;
+	return NULL;
+}
+
+void evfd::vfd_write_string(char * str)
+{
+	int i = strlen(str);
+	if (blocked)
+	{
+		pthread_cancel(thread_start_loop);
+		pthread_join(thread_start_loop, NULL);
+		blocked=false;
+	}
+	memset(g_str,0,64);
+	strcpy(g_str,str);
+	vfd_write_string(str, false);
+	if (i > VFDLENGTH && VFD_SCROLL)
+	{
+		blocked = true;
+		pthread_create(&thread_start_loop, NULL, vfd_write_string_scrollText1, (void *)str);
+		pthread_detach(thread_start_loop);
+	}
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int ws = 0;
+	int i = strlen(str);
+	if (VFD_CENTER)
+	{
+		if (i < VFDLENGTH)
+			ws=(VFDLENGTH-i)/2;
+		else
+			ws=0;
+	}
+	if (i > VFDLENGTH) i = VFDLENGTH;
+	struct vfd_ioctl_data data;
+	memset(data.data, ' ', VFDLENGTH);
+	if (VFD_CENTER)
+		memcpy(data.data+ws, str, VFDLENGTH-ws);
+	else
+		memcpy(data.data, str, i);
+	data.start = 0;
+	if (VFD_CENTER)
+		data.length = i+ws<=VFDLENGTH?i+ws:VFDLENGTH;
+	else
+		data.length = i;
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		write(file_vfd,data.data,data.length);
+		close (file_vfd);
+	return;
+}
+
+#else
+
+void evfd::vfd_write_string(char * str)
+{
+	vfd_write_string(str, false);
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int i;
+	i = strlen ( str );
+	if ( i > 63 ) i = 63;
+	memset ( chars, ' ', 63 );
+	memcpy ( chars, str, i);
+#ifdef PLATFORM_TF7700
+	// request the display to cancel the start loop
+	requested = true;
+	while(blocked) usleep(200000);
+	{
+#else
+	if (!blocked || force)
+	{
+#endif
+		struct vfd_ioctl_data data;
+		memset ( data.data, ' ', 63 );
+		memcpy ( data.data, str, i );
+
+		data.start = 0;
+		data.length = i;
+
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl ( file_vfd, VFDDISPLAYCHARS, &data );
+		close (file_vfd);
+	}
+	return;
+}
+
+void evfd::vfd_write_string_scrollText(char* text)
+{
+	if (!blocked)
+	{
+		int i, len = strlen(text);
+		char* out = (char *) malloc(16);
+		for (i=0; i<=(len-16); i++)
+		{ // scroll text till end
+			memset(out, ' ', 16);
+			memcpy(out, text+i, 16);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+		for (i=1; i<16; i++)
+		{ // scroll text with whitespaces from right
+			memset(out, ' ', 16);
+			memcpy(out, text+len+i-16, 16-i);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+		memcpy(out, text, 16); // display first 16 chars after scrolling
+		vfd_write_string(out);
+		free (out);
+	}
+	return;
+}
+#endif
+void evfd::vfd_clear_string()
+{
+	vfd_write_string("                ");
+	return;
+}
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff)
+{
+	vfd_set_icon(id, onoff, false);
+	return;
+}
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff, bool force)
+{
+	icon_onoff[id] = onoff;
+	if (!blocked || force)
+	{
+		struct vfd_ioctl_data data;
+		if (!startloop_running)
+		{
+			memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+			data.start = 0x00;
+			data.data[0] = id;
+			data.data[4] = onoff;
+			data.length = 5;
+
+			file_vfd = open (VFD_DEVICE, O_WRONLY);
+			ioctl(file_vfd, VFDICONDISPLAYONOFF, &data);
+			close (file_vfd);
+		}
+	}
+	return;
+}
+
+void evfd::vfd_clear_icons()
+{
+	for (int id = 0x10; id < 0x20; id++)
+	{
+		vfd_set_icon((tvfd_icon)id, false);
+	}
+	return;
+}
+
+void evfd::vfd_set_brightness(unsigned char setting)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	data.start = setting & 0x07;
+	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl ( file_vfd, VFDBRIGHTNESS, &data );
+	close (file_vfd);
+
+	return;
+}
+
+void evfd::vfd_set_light(bool onoff)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+		data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDDISPLAYWRITEONOFF, &data);
+
+	close (file_vfd);
+	return;
+}
+
+void evfd::vfd_set_fan(bool onoff)
+{
+#if defined(PLATFORM_CUBEREVO) || defined(PLATFORM_CUBEREVO_MINI) || defined(PLATFORM_CUBEREVO_MINI2) || defined(PLATFORM_CUBEREVO_MINI_FTA) || defined(PLATFORM_CUBEREVO_250HD) || defined(PLATFORM_CUBEREVO_2000HD) || defined(PLATFORM_CUBEREVO_9500HD)
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+		data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, 0xc0425af8, &data);
+
+	close (file_vfd);
+#endif
+	return;
+}
+
+void evfd::vfd_set_SCROLL(int id)
+{
+	VFD_SCROLL=id;
+}
+
+void evfd::vfd_set_CENTER(bool id)
+{
+	VFD_CENTER=id;
+}
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/driver/vfd.h enigma2-nightly/lib/driver/vfd.h
--- enigma2-nightly.org/lib/driver/vfd.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/driver/vfd.h	2013-01-31 12:39:33.984182822 +0100
@@ -0,0 +1,49 @@
+#ifndef VFD_H_
+#define VFD_H_
+
+#define ICON_ON  1
+#define ICON_OFF 0
+
+#ifndef PLATFORM_HDBOX
+typedef enum { USB = 0x10, HD, HDD, LOCK, BT, MP3, MUSIC, DD, MAIL, MUTE, PLAY, PAUSE, FF, FR, REC, CLOCK } tvfd_icon;
+#else
+typedef enum { USB = 0x10, STANDBY, SAT, REC, TIMESHIFT, TIMER, HD, LOCK, DD, MUTE, TUNER1, TUNER2, MP3, REPEAT,
+			    PLAY, PAUSE, TER, FILE, 480i, 480p, 576i, 576p, 720p, 1080i, 1080p } tvfd_icon;
+#endif
+
+class evfd
+{
+protected:
+	static evfd *instance;
+	int file_vfd;
+	int vfd_type;
+#ifdef SWIG
+	evfd();
+	~evfd();
+#endif
+public:
+#ifndef SWIG
+	evfd();
+	~evfd();
+#endif
+	void init();
+	static evfd* getInstance();
+
+	int getVfdType() { return vfd_type; }
+	void vfd_set_SCROLL(int id);
+	void vfd_set_CENTER(bool id);
+	void vfd_set_icon(tvfd_icon id, bool onoff);
+	void vfd_set_icon(tvfd_icon id, bool onoff, bool force);
+	void vfd_clear_icons();
+
+	void vfd_write_string(char * string);
+	void vfd_write_string(char * str, bool force);
+	void vfd_write_string_scrollText(char* text);
+	void vfd_clear_string();
+	
+	void vfd_set_brightness(unsigned char setting);
+	void vfd_set_light(bool onoff);
+	void vfd_set_fan(bool onoff);
+};
+
+#endif
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb/decoder.cpp enigma2-nightly/lib/dvb/decoder.cpp
--- enigma2-nightly.org/lib/dvb/decoder.cpp	2013-01-31 12:39:33.620182806 +0100
+++ enigma2-nightly/lib/dvb/decoder.cpp	2013-01-31 12:39:33.984182822 +0100
@@ -40,7 +40,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_AUDIO1 : DMX_PES_AUDIO0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - audio - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -48,6 +52,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - audio - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -55,6 +60,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	int bypass = 0;
 
 	switch (type)
@@ -90,7 +96,9 @@
 		eDebug("failed (%m)");
 	else
 		eDebug("ok");
+#if not defined(__sh__) // this is a hack which only matters for dm drivers
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("AUDIO_PLAY - ");
 	if (::ioctl(m_fd, AUDIO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -265,7 +273,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_VIDEO1 : DMX_PES_VIDEO0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - video - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -273,6 +285,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - video - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -281,6 +294,7 @@
 	}
 	eDebug("ok");
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("VIDEO_PLAY - ");
 	if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -522,7 +536,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_PCR1 : DMX_PES_PCR0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - pcr - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -530,6 +548,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - pcr - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -537,6 +556,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -593,6 +618,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -728,12 +754,28 @@
 		int *s = state_table[m_state];
 		if (changed & (changeState|changeVideo) && m_video)
 		{
+#if not defined(__sh__) // see comment below
 			m_video->setSlowMotion(s[1]);
 			m_video->setFastForward(s[2]);
+#endif 
 			if (s[0])
 				m_video->unfreeze();
 			else
 				m_video->freeze();
+#if defined(__sh__)
+// the VIDEO_CONTINUE would reset the FASTFORWARD  command so we
+// execute the FASTFORWARD after the VIDEO_CONTINUE
+			if (s[1])
+			{
+				m_video->setFastForward(s[2]);
+				m_video->setSlowMotion(s[1]);
+			}
+			else
+			{
+				m_video->setSlowMotion(s[1]);
+				m_video->setFastForward(s[2]);
+			}
+#endif
 		}
 		if (changed & (changeState|changeAudio) && m_audio)
 		{
@@ -1019,6 +1061,10 @@
 		{
 			struct stat s;
 			fstat(f, &s);
+#if defined(__sh__) // our driver has a different behaviour for iframes
+			if (m_video_clip_fd >= 0)
+				finishShowSinglePic();
+#endif
 			if (m_video_clip_fd == -1)
 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
 			if (m_video_clip_fd >= 0)
@@ -1039,8 +1085,10 @@
 
 				if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0)
 					eDebug("VIDEO_SELECT_SOURCE MEMORY failed (%m)");
+#if not defined(__sh__)
 				if (ioctl(m_video_clip_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
 					eDebug("VIDEO_SET_STREAMTYPE failed(%m)");
+#endif 
 				if (ioctl(m_video_clip_fd, VIDEO_PLAY) < 0)
 					eDebug("VIDEO_PLAY failed (%m)");
 				if (ioctl(m_video_clip_fd, VIDEO_CONTINUE) < 0)
@@ -1057,7 +1105,9 @@
 				if (!seq_end_avail)
 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
 				write(m_video_clip_fd, stuffing, 8192);
+#if not defined(__sh__)
 				m_showSinglePicTimer->start(150, true);
+#endif 
 			}
 			close(f);
 		}
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb/dvb.cpp enigma2-nightly/lib/dvb/dvb.cpp
--- enigma2-nightly.org/lib/dvb/dvb.cpp	2013-01-31 12:39:33.620182806 +0100
+++ enigma2-nightly/lib/dvb/dvb.cpp	2013-01-31 12:39:33.984182822 +0100
@@ -114,6 +114,62 @@
 		m_boxtype = DM800SE;
 	else if (!strncmp(tmp, "dm7020hd\n", rd))
 		m_boxtype = DM7020HD;
+#if defined(__sh__)
+	else if (!strncmp(tmp, "adb_box\n", rd))
+		m_boxtype = ADB_BOX;
+	else if (!strncmp(tmp, "ufs910\n", rd))
+		m_boxtype = UFS910;
+	else if (!strncmp(tmp, "ufs912\n", rd))
+		m_boxtype = UFS912;
+	else if (!strncmp(tmp, "ufs913\n", rd))
+		m_boxtype = UFS913;
+	else if (!strncmp(tmp, "ufs922\n", rd))
+		m_boxtype = UFS922;
+	else if (!strncmp(tmp, "tf7700hdpvr\n", rd))
+		m_boxtype = TF7700HDPVR;
+	else if (!strncmp(tmp, "hdbox\n", rd))
+		m_boxtype = HDBOX;
+	else if (!strncmp(tmp, "hl101\n", rd))
+		m_boxtype = HL101;
+	else if (!strncmp(tmp, "spark\n", rd))
+		m_boxtype = SPARK;
+	else if (!strncmp(tmp, "spark7162\n", rd))
+		m_boxtype = SPARK7162;
+	else if (!strncmp(tmp, "vip1-v2\n", rd))
+		m_boxtype = VIP1_V2;
+	else if (!strncmp(tmp, "vip2-v1\n", rd))
+		m_boxtype = VIP2_V1;
+	else if (!strncmp(tmp, "cuberevo\n", rd))
+		m_boxtype = CUBEREVO;
+	else if (!strncmp(tmp, "cuberevo-9500hd\n", rd))
+		m_boxtype = CUBEREVO_9500HD;
+	else if (!strncmp(tmp, "cuberevo-mini\n", rd))
+		m_boxtype = CUBEREVO_MINI;
+	else if (!strncmp(tmp, "cuberevo-mini2\n", rd))
+		m_boxtype = CUBEREVO_MINI2;
+	else if (!strncmp(tmp, "cuberevo-2000hd\n", rd))
+		m_boxtype = CUBEREVO_2000HD;
+	else if (!strncmp(tmp, "cuberevo-250hd\n", rd))
+		m_boxtype = CUBEREVO_250HD;
+	else if (!strncmp(tmp, "cuberevo-mini-fta\n", rd))
+		m_boxtype = CUBEREVO_MINI_FTA;
+	else if (!strncmp(tmp, "ipbox9900\n", rd))
+		m_boxtype = IPBOX9900;
+	else if (!strncmp(tmp, "ipbox99\n", rd))
+		m_boxtype = IPBOX99;
+	else if (!strncmp(tmp, "ipbox55\n", rd))
+		m_boxtype = IPBOX55;
+	else if (!strncmp(tmp, "octagon1008\n", rd))
+		m_boxtype = OCTAGON1008;
+	else if (!strncmp(tmp, "hs7810a\n", rd))
+		m_boxtype = HS7810A;
+	else if (!strncmp(tmp, "hs7110\n", rd))
+		m_boxtype = HS7110;
+	else if (!strncmp(tmp, "whitebox\n", rd))
+		m_boxtype = WHITEBOX;
+	else if (!strncmp(tmp, "atevio7500\n", rd))
+		m_boxtype = ATEVIO7500;
+#else
 	else {
 		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
 		if (m_demux.size() == 3)
@@ -123,7 +179,7 @@
 		else
 			m_boxtype = DM8000;
 	}
-
+#endif
 	eDebug("found %zd adapter, %zd frontends(%zd sim) and %zd demux, boxtype %d",
 		m_adapter.size(), m_frontend.size(), m_simulate_frontend.size(), m_demux.size(), m_boxtype);
 
@@ -969,6 +1025,58 @@
 			}
 		}
 	}
+#if defined(__sh__) // we use our own algo for demux detection
+	else if (m_boxtype == ADB_BOX || m_boxtype == UFS910 || m_boxtype == UFS912 || m_boxtype == UFS913 || m_boxtype == UFS922 || m_boxtype == SPARK || m_boxtype == SPARK7162 || m_boxtype == TF7700HDPVR || m_boxtype == HDBOX ||
+		m_boxtype == HL101 || m_boxtype == CUBEREVO || m_boxtype == CUBEREVO_MINI || m_boxtype == CUBEREVO_MINI2 || m_boxtype == VIP1_V2 || m_boxtype == VIP2_V1 || m_boxtype == HS7810A || m_boxtype == HS7110 || m_boxtype == WHITEBOX ||
+		m_boxtype == CUBEREVO_MINI_FTA || m_boxtype == CUBEREVO_250HD || m_boxtype == CUBEREVO_2000HD || m_boxtype == CUBEREVO_9500HD || m_boxtype == OCTAGON1008 || m_boxtype == ATEVIO7500 ||
+		m_boxtype == IPBOX9900 || m_boxtype == IPBOX99 || m_boxtype == IPBOX55)
+	{
+		int n=0;
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			if(fe)
+			{
+				if (!i->m_inuse)
+				{
+					if (!unused)
+					{
+						// take the first unused
+						//eDebug("\nallocate demux b = %d\n",n);
+						unused = i;
+					}
+				}
+				else if (i->m_adapter == fe->m_adapter && i->m_demux->getSource() == fe->m_frontend->getDVBID())
+				{
+					// take the demux allocated to the same
+					// frontend,  just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux b = %d\n",n);
+					return 0;
+				}
+			}
+			else if(n == (m_demux.size() - 1))
+			{
+				// Always use the last demux for PVR
+				// it is assumed that the last demux is not
+				// attached to a frontend. That is, there
+				// should be one instance of dvr & demux
+				// devices more than of frontend devices.
+				// Otherwise, playback and timeshift might
+				// interfere recording.
+				if (i->m_inuse)
+				{
+					// just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux c = %d\n",n);
+					return 0;
+				}
+				unused = i;
+				//eDebug("\nallocate demux d = %d\n", n);
+				break;
+			}
+		}
+	}
+#endif
 	else
 	{
 		iDVBAdapter *adapter = fe ? fe->m_adapter : m_adapter.begin(); /* look for a demux on the same adapter as the frontend, or the first adapter for dvr playback */
@@ -2143,6 +2251,12 @@
 			return -ENODEV;
 		}
 #else
+#if defined(__sh__) // our pvr device is called dvr
+		char dvrDev[128];
+		int dvrIndex = m_mgr->m_adapter.begin()->getNumDemux() - 1;
+		sprintf(dvrDev, "/dev/dvb/adapter0/dvr%d", dvrIndex);
+		m_pvr_fd_dst = open(dvrDev, O_WRONLY);
+#else
 		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
 		if (demux)
 		{
@@ -2159,6 +2273,7 @@
 			return -ENODEV;
 		}
 #endif
+#endif
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush(m_source->getPacketSize());
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb/dvb.h enigma2-nightly/lib/dvb/dvb.h
--- enigma2-nightly.org/lib/dvb/dvb.h	2013-01-31 12:39:33.620182806 +0100
+++ enigma2-nightly/lib/dvb/dvb.h	2013-01-31 12:39:33.984182822 +0100
@@ -165,7 +165,11 @@
 	DECLARE_REF(eDVBResourceManager);
 	int avail, busy;
 
+#if not defined(__sh__)
 	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD };
+#else
+	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD, ADB_BOX, UFS910, UFS912, UFS913, UFS922, TF7700HDPVR, HDBOX, HL101, CUBEREVO, CUBEREVO_MINI, CUBEREVO_MINI2, CUBEREVO_MINI_FTA, CUBEREVO_250HD, CUBEREVO_9500HD, CUBEREVO_2000HD, IPBOX9900, IPBOX99, IPBOX55, OCTAGON1008, VIP1_V2, VIP2_V1, SPARK, SPARK7162, ATEVIO7500, HS7810A, HS7110, WHITEBOX};
+#endif
 
 	int m_boxtype;
 
@@ -277,6 +281,9 @@
 		/* cannot be used for PVR channels. */
 	RESULT setChannel(const eDVBChannelID &id, ePtr<iDVBFrontendParameters> &feparam);
 	eDVBChannelID getChannelID() { return m_channel_id; }
+#if defined(__sh__) //see filepush.h
+	int getSkipMode() { return m_skipmode_m; }
+#endif
 
 	RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
 	RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb/epgcache.cpp enigma2-nightly/lib/dvb/epgcache.cpp
--- enigma2-nightly.org/lib/dvb/epgcache.cpp	2013-01-31 12:39:33.620182806 +0100
+++ enigma2-nightly/lib/dvb/epgcache.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -249,12 +261,23 @@
 	if ( ByteSize )
 	{
 		CacheSize -= ByteSize;
+#ifndef __sh__
 		__u32 *d = (__u32*)(EITdata+10);
+#else	// Dagobert: fix not aligned access
+		__u8 *d = (__u8*)(EITdata+10);
+#endif
 		ByteSize -= 10;
 		while(ByteSize>3)
 		{
+#ifndef __sh__
 			descriptorMap::iterator it =
 				descriptors.find(*d++);
+#else
+			__u32 index = d[3] << 24 | d[2] << 16 | d[1] << 8 | d[0];
+			// eDebug("index %d %x, %x %x %x %x\n", index, index, d[0], d[1], d[2], d[3]);
+			descriptorMap::iterator it = descriptors.find(index);
+			d += 4;
+#endif
 			if ( it != descriptors.end() )
 			{
 				descriptorPair &p = it->second;
@@ -1894,6 +1956,10 @@
 			cache->sectionRead(data, source, this);
 		}
 	}
+#ifdef __sh__
+	if (isNotAligned)
+		free((void *)aligned_data);
+#endif
 }
 
 #if ENABLE_FREESAT
					if (it != eventData::descriptors.end())
@@ -3160,12 +3235,21 @@
 				}
 				__u8 *data = evit->second->EITdata;
 				int tmp = evit->second->ByteSize-10;
+#ifndef __sh__
 				__u32 *p = (__u32*)(data+10);
+#else	// Dagobert: Alignment fix
+				__u8 *p = (__u8*)(data+10);
+#endif
 				// check if any of our descriptor used by this event
 				int cnt=-1;
 				while(tmp>3)
 				{
+#ifndef __sh__
 					__u32 crc32 = *p++;
+#else	// Dagobert: Alignment fix
+					__u32 crc32 = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+					p += 4;
+#endif
 					for ( int i=0; i <= descridx; ++i)
 					{
 						if (descr[i] == crc32)  // found...
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb/pmt.cpp enigma2-nightly/lib/dvb/pmt.cpp
--- enigma2-nightly.org/lib/dvb/pmt.cpp	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/dvb/pmt.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -1106,6 +1106,11 @@
 			eDVBCIInterfaces::getInstance()->addPMTHandler(this);
 	} else if (!simulate) // no simulation of playback services
 	{
+		if (m_service_type == streamclient)
+		{
+			eDebug("force setServiceID(1)");
+			m_reference.setServiceID(1);
+		}
 		if (!ref.getServiceID().get() /* incorrect sid in meta file or recordings.epl*/ )
 		{
 			eDVBTSTools tstools;

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb/volume.cpp enigma2-nightly/lib/dvb/volume.cpp
--- enigma2-nightly.org/lib/dvb/volume.cpp	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/dvb/volume.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -34,7 +34,9 @@
 	openMixer();
 #endif
 	volumeUnMute();
+#if not defined (__sh__) // dont reset volume on start
 	setVolume(100, 100);
+#endif
 }
 
 int eDVBVolumecontrol::openMixer()
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb_ci/dvbci_appmgr.cpp enigma2-nightly/lib/dvb_ci/dvbci_appmgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_appmgr.cpp	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_appmgr.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -94,6 +94,9 @@
 	eDebug("in appmanager -> startmmi()");
 	const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
 	sendAPDU(tag);
+#ifdef __sh__
+	slot->mmiOpened();
+#endif
 	return 0;
 }
 
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb_ci/dvbci.cpp enigma2-nightly/lib/dvb_ci/dvbci.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci.cpp	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -18,6 +18,11 @@
 
 #include <dvbsi++/ca_program_map_section.h>
 
+#ifdef __sh__
+#include <linux/dvb/ca.h>
+//#define x_debug
+#endif
+
 //#define CIDEBUG 1
 
 #ifdef CIDEBUG
@@ -28,6 +33,229 @@
 
 eDVBCIInterfaces *eDVBCIInterfaces::instance = 0;
 
+#ifdef __sh__
+bool eDVBCISlot::checkQueueSize()
+{
+	return (sendqueue.size() > 0);
+}
+
+/* from dvb-apps */
+int asn_1_decode(uint16_t * length, unsigned char * asn_1_array,
+		 uint32_t asn_1_array_len)
+{
+	uint8_t length_field;
+
+	if (asn_1_array_len < 1)
+		return -1;
+	length_field = asn_1_array[0];
+
+	if (length_field < 0x80) {
+		// there is only one word
+		*length = length_field & 0x7f;
+		return 1;
+	} else if (length_field == 0x81) {
+		if (asn_1_array_len < 2)
+			return -1;
+
+		*length = asn_1_array[1];
+		return 2;
+	} else if (length_field == 0x82) {
+		if (asn_1_array_len < 3)
+			return -1;
+
+		*length = (asn_1_array[1] << 8) | asn_1_array[2];
+		return 3;
+	}
+
+	return -1;
+}
+
+//send some data on an fd, for a special slot and connection_id
+eData eDVBCISlot::sendData(unsigned char* data, int len)
+{
+#ifdef x_debug
+	printf("%s: %p, %d\n", __func__, data, len);
+#endif
+
+	unsigned char *d = (unsigned char*) malloc(len + 5);
+
+	/* should we send a data last ? */
+	if (data != NULL)
+	{
+		if ((data[2] >= T_SB) && (data[2] <= T_NEW_T_C))
+		{
+			memcpy(d, data, len);
+		}
+		else
+		{
+			//send data_last and data
+			memcpy(d + 5, data, len);
+			d[0] = getSlotID();
+			d[1] = connection_id;
+			d[2] = T_DATA_LAST;
+			d[3] = len + 1; 		/* len */
+			d[4] = connection_id; 	/* transport connection identifier*/
+			len += 5;
+		}
+	}
+	else
+	{
+		//send a data last only
+		d[0] = getSlotID();
+		d[1] = connection_id;
+		d[2] = T_DATA_LAST;
+		d[3] = len + 1; 		/* len */
+		d[4] = connection_id; 	/* transport connection identifier*/
+		len = 5;
+	}
+
+#ifdef x_debug
+	printf("write (%d): > ", getSlotID());
+	for (int i=0; i < len; i++)
+		printf("%02x ",d[i]);
+	printf("\n");
+#endif
+
+#ifdef direct_write
+	res = write(fd, d, len);
+
+	free(d);
+	if (res < 0 || res != len)
+	{
+		printf("error writing data to fd %d, slot %d: %m\n", fd, getSlotID());
+		return eDataError;
+	}
+#else
+	sendqueue.push( queueData(d, len) );
+#endif
+	return eDataReady;
+}
+
+//send a transport connection create request
+bool eDVBCISlot::sendCreateTC()
+{
+	//printf("%s:%s >\n", FILENAME, __FUNCTION__);
+	unsigned char* data = (unsigned char*) malloc(sizeof(char) * 5);
+	tx_time.tv_sec = 0;
+	data[0] = getSlotID();
+	data[1] = getSlotID() + 1; 	/* conid */
+	data[2] = T_CREATE_T_C;
+	data[3] = 1;
+	data[4] = getSlotID() + 1 	/*conid*/;
+	write(fd, data, 5);
+	//printf("%s:%s <\n", FILENAME, __FUNCTION__);
+	return true;
+}
+
+void eDVBCISlot::process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id)
+{
+	switch (tpdu_tag)
+	{
+		case T_C_T_C_REPLY:
+			printf("Got CTC Replay (slot %d, con %d)\n", getSlotID(), connection_id);
+
+			tx_time.tv_sec = 0;
+
+			state = stateInserted;
+
+			//answer with data last (and if we have with data)
+			sendData(NULL, 0);
+
+			break;
+		case T_DELETE_T_C:
+//FIXME: close sessions etc; reset ?
+//we must answer here with t_c_replay
+			printf("Got \"Delete Transport Connection\" from module ->currently not handled!\n");
+			break;
+		case T_D_T_C_REPLY:
+			printf("Got \"Delete Transport Connection Replay\" from module!\n");
+			break;
+		case T_REQUEST_T_C:
+			printf("Got \"Request Transport Connection\" from Module ->currently not handled!\n");
+			break;
+		case T_DATA_MORE:
+		{
+			int new_data_length = receivedLen + asn_data_length;
+			printf("Got \"Data More\" from Module\n");
+			__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+			receivedData = new_data_buffer;
+			memcpy(receivedData + receivedLen, data, asn_data_length);
+			receivedLen = new_data_length;
+			tx_time.tv_sec = 0;
+			break;
+		}
+		case T_DATA_LAST:
+#ifdef x_debug
+			printf("Got \"Data Last\" from Module\n");
+#endif
+			tx_time.tv_sec = 0;
+			/* single package */
+			if (receivedData == NULL)
+			{
+				printf("->single package\n");
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < asn_data_length; i++)
+					printf("%02x ", data[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, data, asn_data_length);
+				eDVBCISession::pollAll();
+			}
+			else
+			{
+				/* chained package */
+				int new_data_length = receivedLen + asn_data_length;
+				printf("->chained data\n");
+				__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+				receivedData = new_data_buffer;
+				memcpy(receivedData + receivedLen, data, asn_data_length);
+				receivedLen = new_data_length;
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < receivedLen; i++)
+					printf("%02x ", receivedData[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, receivedData, receivedLen);
+				eDVBCISession::pollAll();
+//fixme: must also be moved in e2 behind the data processing ;)
+				free(receivedData);
+				receivedData = NULL;
+				receivedLen = 0;
+			}
+			break;
+		case T_SB:
+		{
+#ifdef x_debug
+			printf("Got \"SB\" from Module\n");
+#endif
+			if (data[0] & 0x80)
+			{
+				printf("->data ready (%d)\n", getSlotID());
+				// send the RCV and ask for the data
+				unsigned char send_data[5];
+				send_data[0] = getSlotID();
+				send_data[1] = connection_id;
+				send_data[2] = T_RCV;
+				send_data[3] = 1;
+				send_data[4] = connection_id;
+				write(fd, send_data, 5);
+				gettimeofday(&tx_time, 0);
+			}
+			else
+			{
+				tx_time.tv_sec = 0;
+			}
+			break;
+		}
+		default:
+			printf("unhandled tpdu_tag 0x%0x\n", tpdu_tag);
+	}
+}
+
+#endif
+
 eDVBCIInterfaces::eDVBCIInterfaces()
 {
 	int num_ci = 0;
@@ -39,7 +267,11 @@
 	while (1)
 	{
 		char filename[128];
+#ifdef __sh__
+		sprintf(filename, "/dev/dvb/adapter0/ci%d", num_ci);
+#else
 		sprintf(filename, "/dev/ci%d", num_ci);
+#endif
 
 		if (::access(filename, R_OK) < 0) break;
 
@@ -955,8 +1187,13 @@
 	{
 		unsigned char *d = new unsigned char[len];
 		memcpy(d, data, len);
+#ifdef __sh__
+		sendData(d, len);
+		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#else
 		sendqueue.push( queueData(d, len) );
 		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 	}
 
 	return res;
@@ -965,6 +1202,7 @@
 void eDVBCISlot::data(int what)
 {
 	eDebugCI("CISlot %d what %d\n", getSlotID(), what);
+#ifndef __sh__
 	if(what == eSocketNotifier::Priority) {
 		if(state != stateRemoved) {
 			state = stateRemoved;
@@ -1020,6 +1258,166 @@
 		else
 			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
 	}
+#else
+	unsigned char data[1024];
+	int len = 1024;
+	unsigned char* d;
+	eData status;
+	ca_slot_info_t info;
+
+	if (what & eSocketNotifier::Read)
+	{
+		eDebugCI("eSocketNotifier::Read\n");
+		status = eDataReady;
+		len = ::read(fd, data, len);
+	}
+	else if (what & eSocketNotifier::Write)
+	{
+		eDebugCI("eSocketNotifier::Write\n");
+		status = eDataWrite;
+	}
+	else if (what & eSocketNotifier::Priority)
+	{
+		eDebugCI("eSocketNotifier::Priority\n");
+		status = eDataStatusChanged;
+	}
+
+	switch (getState())
+	{
+		case stateInvalid:
+		{
+			if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("1. cam status changed ->cam now present\n");
+					state = stateInserted;
+					mmi_active = false;
+					tx_time.tv_sec = 0;
+					application_manager = 0;
+					ca_manager = 0;
+					sendCreateTC();
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1);
+				}
+			}
+			else
+			{
+				usleep(100000);
+			}
+		}
+		break;
+		case stateInserted:
+		{
+			if (status == eDataReady)
+			{
+				eDebugCI("received data - len %d\n", len);
+				//int s_id = data[0];
+				//int c_id = data[1];
+				//printf("%d: s_id = %d, c_id = %d\n", slot->slot, s_id, c_id);
+				d = data;
+				/* taken from the dvb-apps */
+				int data_length = len - 2;
+				d += 2; /* remove leading slot and connection id */
+				while (data_length > 0)
+				{
+					unsigned char tpdu_tag = d[0];
+					unsigned short asn_data_length;
+					int length_field_len;
+					if ((length_field_len = asn_1_decode(&asn_data_length, d + 1, data_length - 1)) < 0)
+					{
+						printf("Received data with invalid asn from module on slot %02x\n", getSlotID());
+						break;
+					}
+
+					if ((asn_data_length < 1) || (asn_data_length > (data_length - (1 + length_field_len))))
+					{
+						printf("Received data with invalid length from module on slot %02x\n", getSlotID());
+						break;
+					}
+					connection_id = d[1 + length_field_len];
+					//printf("Setting connection_id from received data to %d\n", slot->connection_id);
+					d += 1 + length_field_len + 1;
+					data_length -= (1 + length_field_len + 1);
+					asn_data_length--;
+					process_tpdu(tpdu_tag, d, asn_data_length, connection_id);
+					// skip over the consumed data
+					d += asn_data_length;
+					data_length -= asn_data_length;
+				} // while (data_length)
+			} /* data ready */
+			else if (status == eDataWrite)
+			{
+				if (!sendqueue.empty() && (tx_time.tv_sec == 0)) 
+				{
+					const queueData &qe = sendqueue.top();
+					int res = write(fd, qe.data, qe.len);
+					if (res >= 0 && (unsigned int)res == qe.len)
+					{
+						delete [] qe.data;
+						sendqueue.pop();
+						gettimeofday(&tx_time, 0);
+					}
+					else
+					{
+						printf("r = %d, %m\n", res);
+					}
+				}
+				/* the spec say's that we _must_ poll the connection
+				 * if the transport connection is in active state
+				 */
+				if ((tx_time.tv_sec == 0) && (!checkQueueSize()) && (time_after(last_poll_time, 1000)))
+				{
+					sendData(NULL, 0);
+					clock_gettime(CLOCK_MONOTONIC, &last_poll_time);
+				}
+			}
+			else if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("2. cam status changed ->cam now present\n");
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1); 
+				}
+				else if (!(info.flags & CA_CI_MODULE_READY))
+				{
+					printf("cam status changed ->cam now _not_ present\n");
+					eDVBCISession::deleteSessions(this);
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCIInterfaces::getInstance()->ciRemoved(this);
+					eDVBCI_UI::getInstance()->setState(getSlotID(),0);
+					while (sendqueue.size())
+					{
+						delete [] sendqueue.top().data;
+						sendqueue.pop();
+					}
+				}
+			}
+		}
+		break;
+		default:
+			printf("unknown state %d\n", state);
+		break;
+	}
+	notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 }
 
 DEFINE_REF(eDVBCISlot);
@@ -1038,7 +1436,11 @@
 	
 	slotid = nr;
 
+#ifdef __sh__
+	sprintf(filename, "/dev/dvb/adapter0/ci%d", nr);
+#else
 	sprintf(filename, "/dev/ci%d", nr);
+#endif
 
 //	possible_caids.insert(0x1702);
 //	possible_providers.insert(providerPair("PREMIERE", 0xC00000));
@@ -1049,10 +1451,24 @@
 	eDebugCI("CI Slot %d has fd %d", getSlotID(), fd);
 	state = stateInvalid;
 
+#ifdef __sh__
+	receivedLen = 0;
+	receivedData = NULL;
+#endif
 	if (fd >= 0)
 	{
+#ifdef __sh__
+		connection_id = slotid + 1;
+		tx_time.tv_sec = 0;
+		tx_time.tv_usec = 0;
+		last_poll_time.tv_sec = 0;
+		last_poll_time.tv_nsec = 0;
+#endif
 		notifier = eSocketNotifier::create(context, fd, eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 		CONNECT(notifier->activated, eDVBCISlot::data);
+#ifdef __sh__
+		reset();
+#endif
 	} else
 	{
 		perror(filename);
@@ -1088,6 +1504,13 @@
 {
 	eDebug("CI Slot %d: reset requested", getSlotID());
 
+#ifdef __sh__
+	state = stateInvalid;
+	mmi_active = false;
+	eDVBCI_UI::getInstance()->setAppName(getSlotID(), "");
+	eDVBCISession::deleteSessions(this);
+	eDVBCIInterfaces::getInstance()->ciRemoved(this);
+#else
 	if (state == stateInvalid)
 	{
 		unsigned char buf[256];
@@ -1095,6 +1518,7 @@
 		while(::read(fd, buf, 256)>0);
 		state = stateResetted;
 	}
+#endif
 
 	while(sendqueue.size())
 	{
@@ -1102,7 +1526,12 @@
 		sendqueue.pop();
 	}
 
+#ifdef __sh__
+	if (ioctl(fd, CA_RESET, getSlotID()) < 0)
+		eDebug("IOCTL CA_RESET failed for slot %d\n", slotid);
+#else
 	ioctl(fd, 0);
+#endif
 
 	return 0;
 }
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb_ci/dvbci.h enigma2-nightly/lib/dvb_ci/dvbci.h
--- enigma2-nightly.org/lib/dvb_ci/dvbci.h	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci.h	2013-01-31 12:39:33.988182821 +0100
@@ -5,6 +5,9 @@
 
 #include <lib/base/ebase.h>
 #include <lib/service/iservice.h>
+#ifdef __sh__
+#include <lib/base/thread.h>
+#endif
 #include <lib/python/python.h>
 #include <set>
 #include <queue>
@@ -43,6 +46,42 @@
 typedef std::set<uint16_t> caidSet;
 typedef std::set<eServiceReference> serviceSet;
 
+#ifdef __sh__
+/* ********************************** */
+/* constants taken from dvb-apps 
+ */
+#define T_SB                0x80	// sb                           primitive   h<--m
+#define T_RCV               0x81	// receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
+				 // layers
+#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+				 // layers
+
+typedef enum {eDataTimeout, eDataError, eDataReady, eDataWrite, eDataStatusChanged} eData;
+
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
+
 class eDVBCISlot: public iObject, public Object
 {
 	friend class eDVBCIInterfaces;
@@ -66,6 +105,13 @@
 	bool user_mapped;
 	void data(int);
 	bool plugged;
+#ifdef __sh__
+	//dagobert
+	char connection_id;
+	bool mmi_active;
+	int receivedLen;
+	unsigned char* receivedData;
+#endif
 public:
 	enum {stateRemoved, stateInserted, stateInvalid, stateResetted};
 	eDVBCISlot(eMainloop *context, int nr);
@@ -95,6 +141,17 @@
 	int getNumOfServices() { return running_services.size(); }
 	int setSource(data_source source);
 	int setClockRate(int);
+#ifdef __sh__
+	bool checkQueueSize();
+	void thread();
+	void mmiOpened() { mmi_active = true; };
+	void mmiClosed() { mmi_active = false; };
+	void process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id);
+	bool sendCreateTC();
+	eData sendData(unsigned char* data, int len);
+	struct timeval tx_time;
+	struct timespec last_poll_time;
+#endif
 };
 
 struct CIPmtHandler
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb_ci/dvbci_mmi.cpp enigma2-nightly/lib/dvb_ci/dvbci_mmi.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_mmi.cpp	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_mmi.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -25,6 +25,9 @@
 
 eDVBCIMMISession::~eDVBCIMMISession()
 {
+#ifdef __sh__
+	slot->mmiClosed();
+#endif
 	slot->setMMIManager(NULL);
 	eDVBCI_UI::getInstance()->mmiSessionDestroyed(slot->getSlotID());
 }
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb_ci/dvbci_resmgr.cpp enigma2-nightly/lib/dvb_ci/dvbci_resmgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_resmgr.cpp	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_resmgr.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -5,7 +5,12 @@
 
 int eDVBCIResourceManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIResourceManagerSession::%s >", __func__);
+	eDebugNoNewLine("SESSION(%d) %02x %02x %02x (len = %d): ", session_nb, tag[0], tag[1], tag[2], len);
+#else
 	eDebugNoNewLine("SESSION(%d) %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
+#endif
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
 	eDebug("");
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/dvb_ci/dvbci_session.cpp enigma2-nightly/lib/dvb_ci/dvbci_session.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_session.cpp	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_session.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -257,6 +257,12 @@
 		if ((!session_nb) || (session_nb >= SLMS))
 		{
 			eDebug("PROTOCOL: illegal session number %x", session_nb);
+#ifdef __sh__
+			//Dagobert during start-up we seems to have some problems
+			//on some modules which "looses" the connection. So reset it
+			deleteSessions(slot);
+			slot->reset();
+#endif
 			return;
 		}
 		
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/accel.cpp enigma2-nightly/lib/gdi/accel.cpp
--- enigma2-nightly.org/lib/gdi/accel.cpp	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/gdi/accel.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -9,8 +9,25 @@
 #include <lib/gdi/gpixmap.h>
 
 gAccel *gAccel::instance;
+#if not defined(__sh__)
 #define BCM_ACCEL
+#else
+#define STMFB_ACCEL
+#endif
 
+#ifdef STMFB_ACCEL
+extern int stmfb_accel_init(void);
+extern void stmfb_accel_close(void);
+extern void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight);
+extern void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color);
+#endif
 #ifdef ATI_ACCEL
 extern int ati_accel_init(void);
 extern void ati_accel_close(void);
@@ -48,6 +65,9 @@
 	m_accel_allocation = 0;
 	instance = this;
 
+#ifdef STMFB_ACCEL
+	stmfb_accel_init();
+#endif
 #ifdef ATI_ACCEL	
 	ati_accel_init();
 #endif
@@ -58,6 +78,9 @@
 
 gAccel::~gAccel()
 {
+#ifdef STMFB_ACCEL
+	stmfb_accel_close();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_close();
 #endif
@@ -103,6 +126,77 @@
 
 int gAccel::blit(gSurface *dst, const gSurface *src, const eRect &p, const eRect &area, int flags)
 {
+#ifdef STMFB_ACCEL
+	//eDebug( "src: %4d %4d %4d %4d\tdst: %4d %4d %4d %4d\n"
+	//		"area: %4d %4d %4d %4d\tp: %4d %4d %4d %4d\n",
+	//		src->data_phys, src->x, src->y, src->stride,
+	//		dst->data_phys, dst->x, dst->y, dst->stride, 
+	//		area.left(), area.top(), area.width(), area.height(),
+	//		p.x(), p.y(), p.width(), p.height());
+
+	int src_format = 0;
+	void *data = 0;
+	int data_phys = 0;
+
+	if (src->bpp == 32)
+		src_format = 0;
+	else if ((src->bpp == 8) && (dst->bpp == 32))
+	{
+		src_format = 1;
+		if (accelAlloc(data, data_phys, area.height() * area.width() * 4))
+			return -1;
+
+		__u8 *srcptr=(__u8*)src->data;
+		__u8 *dstptr=(__u8*)data;
+		__u32 pal[256];
+
+		for (int i=0; i<256; ++i)
+		{
+			if (src->clut.data && (i<src->clut.colors))
+				pal[i]=(src->clut.data[i].a<<24)|(src->clut.data[i].r<<16)|(src->clut.data[i].g<<8)|(src->clut.data[i].b);
+			else
+				pal[i]=0x010101*i;
+			if ((pal[i]&0xFF000000) >= 0xE0000000)
+				pal[i] = 0xFF000000;
+			pal[i]^=0xFF000000;
+		}
+		srcptr+=area.left()*src->bypp+area.top()*src->stride;
+
+		for (int y=0; y<area.height(); y++)
+		{
+			int width=area.width();
+			unsigned char *psrc=(unsigned char*)srcptr;
+			__u32 *pdst=(__u32*)dstptr;
+
+			while (width--)
+				*pdst++=pal[*psrc++];
+
+			srcptr+=src->stride;
+			dstptr+=area.width() * 4;
+		}
+	} else {
+		if (data_phys)
+			accelFree(data_phys);
+		return -1;
+	}
+
+	if (data_phys)
+	{
+		stmfb_accel_blit(
+			data_phys, 0, 0, area.width() * 4, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			0, 0, area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+		accelFree(data_phys);
+	} else {
+		stmfb_accel_blit(
+			src->data_phys, src->x, src->y, src->stride, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			area.left(), area.top(), area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+	}
+	return 0;
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_blit(
 		src->data_phys, src->x, src->y, src->stride,
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/fb.cpp enigma2-nightly/lib/gdi/fb.cpp
--- enigma2-nightly.org/lib/gdi/fb.cpp	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/gdi/fb.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -8,6 +8,9 @@
 #include <linux/kd.h>
 
 #include <lib/gdi/fb.h>
+#ifdef __sh__
+#include <linux/stmfb.h>
+#endif
 
 #ifndef FBIO_WAITFORVSYNC
 #define FBIO_WAITFORVSYNC _IOW('F', 0x20, __u32)

@@ -86,6 +100,7 @@
 
 int fbClass::showConsole(int state)
 {
+#if not defined(__sh__) 
 	int fd=open("/dev/tty0", O_RDWR);
 	if(fd>=0)
 	{

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/fb.h enigma2-nightly/lib/gdi/fb.h
--- enigma2-nightly.org/lib/gdi/fb.h	2013-01-31 12:39:33.624182806 +0100
+++ enigma2-nightly/lib/gdi/fb.h	2013-01-31 12:39:33.988182821 +0100
@@ -49,6 +64,19 @@
 	int PutCMAP();
 #endif
 	static fbClass *getInstance();
+#ifdef ENABLE_LIBEPLAYER3
+//---> "hack" for libeplayer3 fb access
+	int getFD() { return fbFd; }
+	unsigned char * getLFB_Direct() { return lfb; }
+	int getScreenResX() { return xRes; }
+	int getScreenResY() { return yRes; }
+//---<
+#endif
+#if defined(__sh__)
+	void clearFBblit();
+	int getFBdiff(int ret);
+	void setFBdiff(int top, int right, int left, int bottom);
+#endif
 
 	int lock();
 	void unlock();

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/glcddc.cpp enigma2-nightly/lib/gdi/glcddc.cpp
--- enigma2-nightly.org/lib/gdi/glcddc.cpp	2013-01-31 12:39:33.628182807 +0100
+++ enigma2-nightly/lib/gdi/glcddc.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -5,6 +5,21 @@
 
 gLCDDC *gLCDDC::instance;
 
+#ifdef HAVE_GRAPHLCD
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
+
 gLCDDC::gLCDDC()
 {
 	lcd = new eDBoxLCD();

@@ -46,8 +68,16 @@
 		break;
 #endif
 	case gOpcode::flush:
+#ifdef HAVE_GRAPHLCD
+		if (update)
+		{
+			lcd->update();
+			clock_gettime(CLOCK_MONOTONIC, &last_update);
+		}
+#else
 //		if (update)
 			lcd->update();
+#endif
 	default:
 		gDC::exec(o);
 		break;
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/glcddc.h enigma2-nightly/lib/gdi/glcddc.h
--- enigma2-nightly.org/lib/gdi/glcddc.h	2013-01-31 12:39:33.628182807 +0100
+++ enigma2-nightly/lib/gdi/glcddc.h	2013-01-31 12:39:33.988182821 +0100
@@ -11,6 +11,9 @@
 	int update;
 	void exec(const gOpcode *opcode);
 	gSurface surface;
+#ifdef HAVE_GRAPHLCD
+	struct timespec last_update;
+#endif
 public:
 	gLCDDC();
 	~gLCDDC();
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/gpixmap.cpp enigma2-nightly/lib/gdi/gpixmap.cpp
--- enigma2-nightly.org/lib/gdi/gpixmap.cpp	2013-01-31 12:39:33.628182807 +0100
+++ enigma2-nightly/lib/gdi/gpixmap.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -187,6 +187,9 @@
 			else
 				col=0x10101*color;
 			
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 			
 			if (surface->data_phys && gAccel::getInstance())
@@ -219,6 +222,9 @@
 			__u32 col;
 
 			col = color.argb();
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 
 			if (surface->data_phys && gAccel::getInstance())
@@ -400,7 +406,9 @@
 		if (flag & blitScale)
 		{
 			eWarning("unimplemented: scale on non-accel surfaces");
+#if not defined (__sh__) //if accel blit fails, do direkt blit
 			continue;
+#endif
 		}
 
 		if ((surface->bpp == 8) && (src.surface->bpp==8))
@@ -517,6 +525,9 @@
 					pal[i]=(src.surface->clut.data[i].a<<24)|(src.surface->clut.data[i].r<<16)|(src.surface->clut.data[i].g<<8)|(src.surface->clut.data[i].b);
 				else
 					pal[i]=0x010101*i;
+#if defined(__sh__)
+if ((pal[i]&0xFF000000) >= 0xE0000000) pal[i] = 0xFF000000;
+#endif
 				pal[i]^=0xFF000000;
 			}
 
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/lcd.cpp enigma2-nightly/lib/gdi/lcd.cpp
--- enigma2-nightly.org/lib/gdi/lcd.cpp	2013-01-31 12:39:33.628182807 +0100
+++ enigma2-nightly/lib/gdi/lcd.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -60,6 +60,7 @@
 }
 #endif
 
+#ifndef HAVE_GRAPHLCD
 eDBoxLCD::eDBoxLCD()
 {
 	int xres=132, yres=64, bpp=8;

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/lcd.h enigma2-nightly/lib/gdi/lcd.h
--- enigma2-nightly.org/lib/gdi/lcd.h	2013-01-31 12:39:33.628182807 +0100
+++ enigma2-nightly/lib/gdi/lcd.h	2013-01-31 12:39:33.988182821 +0100
@@ -5,6 +5,17 @@
 #include <lib/gdi/esize.h>
 #include <lib/gdi/erect.h>
 
+#ifdef HAVE_GRAPHLCD
+#include <glcdgraphics/bitmap.h>
+#include <glcdgraphics/glcd.h>
+#include <glcdgraphics/image.h>
+#include <glcddrivers/config.h>
+#include <glcddrivers/driver.h>
+#include <glcddrivers/drivers.h>
+#include <glcdgraphics/extformats.h>
+#include <byteswap.h>
+#endif
+
 #define LCD_CONTRAST_MIN 0
 #define LCD_CONTRAST_MAX 63
 #define LCD_BRIGHTNESS_MIN 0
@@ -48,6 +59,13 @@
 	unsigned char inverted;
 	bool flipped;
 	int is_oled;
+#ifdef HAVE_GRAPHLCD
+	GLCD::cDriver * lcd;
+	GLCD::cBitmap * bitmap;
+	int displayNumber;
+	int depth;
+	int width, height;
+#endif
 #ifdef SWIG
 	eDBoxLCD();
 	~eDBoxLCD();

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/picload.cpp enigma2-nightly/lib/gdi/picload.cpp
--- enigma2-nightly.org/lib/gdi/picload.cpp	2013-01-31 12:39:33.628182807 +0100
+++ enigma2-nightly/lib/gdi/picload.cpp	2013-01-31 12:39:33.988182821 +0100
@@ -4,6 +4,7 @@
 
 #include <lib/gdi/picload.h>
 #include <lib/gdi/picexif.h>
+#include "../../../misc/tools/libmmeimage/libmmeimage.h"
 
 extern "C" {
 #include <jpeglib.h>

@@ -1207,3 +1294,65 @@
 
 	return 0;
 }
+
+#if defined(__sh__)
+//---------------------------------------------------------------------------------------------
+
+PyObject *getExif(const char *filename)
+{
+	ePyObject list;
+	Cexif exif;
+	if(exif.DecodeExif(filename))
+	{
+		if(exif.m_exifinfo->IsExif)
+		{
+			int pos=0;
+			char tmp[256];
+			list = PyList_New(22);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Version));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->CameraMake));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->CameraModel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->DateTime));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Comments));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d x %d", exif.m_exifinfo->Width, exif.m_exifinfo->Height));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Orientation));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->MeteringMode));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->ExposureProgram));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->LightSource));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->FlashUsed));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif.m_exifinfo->CompressionLevel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif.m_exifinfo->ISOequivalent));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Xresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Yresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->ResolutionUnit));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Brightness);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f sec.", exif.m_exifinfo->ExposureTime);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->ExposureBias);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->Distance);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->CCDWidth);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->ApertureFNumber);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+		}
+		else
+		{
+			list = PyList_New(1);
+			PyList_SET_ITEM(list, 0, PyString_FromString(exif.m_szLastError));
+		}
+		exif.ClearExif();
+	}
+	else
+	{
+		list = PyList_New(1);
+		PyList_SET_ITEM(list, 0, PyString_FromString(exif.m_szLastError));
+	}
+
+	return list ? (PyObject*)list : (PyObject*)PyList_New(0);
+}
+#endif
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/gdi/stmfb.cpp enigma2-nightly/lib/gdi/stmfb.cpp
--- enigma2-nightly.org/lib/gdi/stmfb.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/gdi/stmfb.cpp	2013-01-31 12:39:33.992182821 +0100
@@ -0,0 +1,75 @@
+/*
+  Interface to the Dreambox dm800/dm8000 proprietary accel interface.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/stmfb.h>
+
+
+#include <lib/base/ebase.h>
+
+static int fb_fd;
+static int exec_list(void);
+
+int stmfb_accel_init(void)
+{
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (fb_fd < 0)
+	{
+		perror("/dev/fb0");
+		return 1;
+	}
+	eDebug("STMFB accel interface available\n");
+	return 0;
+}
+
+void stmfb_accel_close(void)
+{
+	close(fb_fd);
+}
+
+void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight)
+{
+	STMFBIO_BLT_DATA bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = (src_addr - dst_addr) + (1920*1080*4);
+	bltData.srcPitch   = src_stride;
+	bltData.src_left   = src_x;
+	bltData.src_top    = src_y;
+	bltData.src_right  = src_x + width;
+	bltData.src_bottom = src_y + height;
+	bltData.srcFormat  = SURF_BGRA8888;
+
+	bltData.dstOffset  = 1920*1080*4;
+	bltData.dstPitch   = dst_stride;
+	bltData.dst_left   = dst_x;
+	bltData.dst_top    = dst_y;
+	bltData.dst_right  = dst_x + dwidth;
+	bltData.dst_bottom = dst_y + dheight;
+	bltData.dstFormat  = SURF_BGRA8888;
+
+	if (ioctl(fb_fd, STMFBIO_BLT, &bltData ) < 0)
+	{
+		eDebug("Error ioctl FBIO_BLIT");
+	}
+}
+
+void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color)
+{
+//	printf("unimplemented bcm_accel_fill\n");
+}


diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Components/NimManager.py enigma2-nightly/lib/python/Components/NimManager.py
--- enigma2-nightly.org/lib/python/Components/NimManager.py	2013-01-31 12:39:33.636182808 +0100
+++ enigma2-nightly/lib/python/Components/NimManager.py	2013-01-31 12:39:33.992182821 +0100
@@ -20,6 +20,10 @@
 import xml.etree.cElementTree
 
 def getConfigSatlist(orbpos, satlist):
+#+++>  CAUSE OF CRASH!
+	if not satlist:
+		return None
+#+++<
 	default_orbpos = None
 	for x in satlist:
 		if x[0] == orbpos:

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Components/Renderer/Progress.py enigma2-nightly/lib/python/Components/Renderer/Progress.py
--- enigma2-nightly.org/lib/python/Components/Renderer/Progress.py	2013-01-31 12:39:33.636182808 +0100
+++ enigma2-nightly/lib/python/Components/Renderer/Progress.py	2013-01-31 12:39:33.992182821 +0100
@@ -13,25 +13,40 @@
 	GUI_WIDGET = eSlider
 
 	def changed(self, what):
-		if what[0] == self.CHANGED_CLEAR:
-			(self.range, self.value) = ((0, 1), 0)
-			return
-
-		range = self.source.range or 100
-		value = self.source.value
-		if value is None:
-			value = 0
-		(self.range, self.value) = ((0, range), value)
+#+++>
+		try:
+			if what[0] == self.CHANGED_CLEAR:
+				(self.range, self.value) = ((0, 1), 0)
+				return
+
+			range = (self.source and self.source.range) or 100
+			value = (self.source and self.source.value) or 0
+			if value is None:
+				value = 0
+			(self.range, self.value) = ((0, range), value)
+		except:
+			None
+#+++<
 
 	GUI_WIDGET = eSlider
 
 	def postWidgetCreate(self, instance):
-		instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def setRange(self, range):
-		(self.__start, self.__end) = range
-		if self.instance is not None:
-			self.instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			(self.__start, self.__end) = range
+			if self.instance is not None:
+				self.instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def getRange(self):
 		return (self.__start, self.__end)
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Components/Renderer/SingleEpgList.py enigma2-nightly/lib/python/Components/Renderer/SingleEpgList.py
--- enigma2-nightly.org/lib/python/Components/Renderer/SingleEpgList.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Components/Renderer/SingleEpgList.py	2013-01-31 12:39:33.992182821 +0100
@@ -0,0 +1,39 @@
+from Components.VariableText import VariableText
+from enigma import eLabel, eEPGCache
+from Renderer import Renderer
+from time import localtime
+
+class SingleEpgList(Renderer, VariableText):
+	def __init__(self):
+		Renderer.__init__(self)
+		VariableText.__init__(self)
+		self.epgcache = eEPGCache.getInstance()
+
+	GUI_WIDGET = eLabel
+
+	def changed(self, what):
+		event = self.source.event
+
+		if event is None:
+			self.text = ""
+			return
+		service = self.source.service
+		text = ""
+		evt = None
+
+		if self.epgcache is not None:
+			evt = self.epgcache.lookupEvent(['IBDCT', (service.toString(), 0, -1, -1)])
+
+		if evt:
+			maxx = 0
+			for x in evt:
+				if maxx > 0:
+					if x[4]:
+						t = localtime(x[1])
+						text = text + "%02d:%02d %s\n" % (t[3], t[4], x[4])
+					else:
+						text = text + "n/a\n"
+				maxx += 1
+				if maxx > 4:
+					break
+		self.text = text


diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/enigma_python.i enigma2-nightly/lib/python/enigma_python.i
--- enigma2-nightly.org/lib/python/enigma_python.i	2013-01-31 12:39:33.688182810 +0100
+++ enigma2-nightly/lib/python/enigma_python.i	2013-01-31 12:39:33.992182821 +0100
@@ -107,6 +107,7 @@
 #include <lib/dvb_ci/dvbci_ui.h>
 #include <lib/python/python.h>
 #include <lib/gdi/picload.h>
+#include <lib/driver/vfd.h> 
 %}
 
 %feature("ref")   iObject "$this->AddRef(); /* eDebug(\"AddRef (%s:%d)!\", __FILE__, __LINE__); */ "
@@ -244,6 +245,7 @@
 %include <lib/dvb/db.h>
 %include <lib/python/python.h>
 %include <lib/gdi/picload.h>
+%include <lib/driver/vfd.h>
 /**************  eptr  **************/
 
 /**************  signals  **************/

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	2013-01-31 12:39:33.992182821 +0100
@@ -0,0 +1,2 @@
+
+
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	2013-01-31 12:39:33.992182821 +0100
@@ -0,0 +1,5 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/CuberevoVFD
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	2013-01-31 12:39:33.992182821 +0100
@@ -0,0 +1,317 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, configfile, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import *
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from re import compile as re_compile, search as re_search
+
+import os
+
+my_global_session = None
+
+config.plugins.CuberevoVFD = ConfigSubsection()
+config.plugins.CuberevoVFD.scroll = ConfigSelection(default = "once", choices = [("never"), ("once"), ("always")])
+config.plugins.CuberevoVFD.brightness = ConfigSelection(default = "bright", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.CuberevoVFD.showClock = ConfigEnableDisable(default = True)
+#config.plugins.CuberevoVFD.setDaylight = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.timeMode = ConfigSelection(default = "24h", choices = [("12h"),("24h")])
+config.plugins.CuberevoVFD.setLed = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.setFan = ConfigEnableDisable(default = True)
+
+class CuberevoVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="CuberevoVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.CuberevoVFD.showClock))
+		self.list.append(getConfigListEntry(_("Time mode"), config.plugins.CuberevoVFD.timeMode))
+		self.list.append(getConfigListEntry(_("Set led"), config.plugins.CuberevoVFD.setLed))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.CuberevoVFD.brightness))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.CuberevoVFD.scroll))
+		self.list.append(getConfigListEntry(_("Set fan"), config.plugins.CuberevoVFD.setFan))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+		}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+
+		if config.plugins.CuberevoVFD.showClock.getValue():
+			cubeVfd.enableClock()
+		else:
+			cubeVfd.disableClock()
+
+#		if config.plugins.CuberevoVFD.setDaylight.getValue():
+#			cubeVfd.enableDaylight()
+#		else:
+#			cubeVfd.disableDaylight()
+
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			cubeVfd.enableTimeMode()
+		else:
+			cubeVfd.disableTimeMode()
+
+		# enable/disable fan activity
+		if config.plugins.CuberevoVFD.setFan.getValue():
+			cubeVfd.enableFan()
+		else:
+			cubeVfd.disableFan()
+
+		# enable/disable led activity
+		if config.plugins.CuberevoVFD.setLed.getValue():
+			cubeVfd.enableLed()
+		else:
+			cubeVfd.disableLed()
+
+	# set the brightness
+		brightness = 3
+		if config.plugins.CuberevoVFD.brightness.getValue() == "dark":
+			brightness = 1
+		elif config.plugins.CuberevoVFD.brightness.getValue() == "bright":
+			brightness = 7
+		evfd.getInstance().vfd_set_brightness(brightness)
+
+		configfile.save()
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+class CuberevoVFD:
+	def __init__(self, session):
+		#print "CuberevoVFD initializing"
+		global showmenuorpanel
+		showmenuorpanel = False
+		self.showtimer = eTimer()
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		self.Console = Console()
+		self.tsEnabled = False
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+		self.fanEnabled = config.plugins.CuberevoVFD.setFan.getValue()
+		self.ledEnabled = config.plugins.CuberevoVFD.setLed.getValue()
+		self.clockEnabled = config.plugins.CuberevoVFD.showClock.getValue()
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			self.timeModeEnabled = 1
+		else:
+			self.timeModeEnabled = 0
+		if self.fanEnabled == False:
+			self.disableFan()
+		else:
+			self.enableFan()
+		if self.ledEnabled == False:
+			self.disableLed()
+		else:
+			self.enableLed()
+
+	def handleTimer(self):
+		global showmenuorpanel
+		try:
+			from Plugins.Extensions.Aafpanel.plugin import inAAFPanel
+			showPanel = inAAFPanel
+		except:
+			#print '[CuberevoVFD] Error showPanel'
+			showPanel = None
+		try:
+			from Screens.Menu import inMenu
+			showMenu = inMenu
+		except:
+			#print '[CuberevoVFD] Error showMenu'
+			showMenu = None
+		if showMenu or showPanel:
+			self.showtimer.start(4000, True)
+		self.showtimer.callback.append(self.setshowmenuorpanel)
+		if not showMenu and not showPanel and showmenuorpanel is True:
+			showmenuorpanel = False
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename =subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+				evfd.getInstance().vfd_write_string(servicename[0:17])
+
+	def setshowmenuorpanel(self):
+		global showmenuorpanel
+		showmenuorpanel = True
+		self.showtimer.stop()
+
+	def enableClock(self):
+		self.clockEnabled = True
+		try:
+			os.popen("/bin/fp_control -dt 1")
+		except OSError:
+			print "no memory"
+
+	def disableClock(self):
+		self.clockEnabled = False
+		try:
+			os.popen("/bin/fp_control -dt 0")
+		except OSError:
+			print "no memory"
+
+	def enableTimeMode(self):
+		self.timeModeEnabled = 1
+		try:
+			os.popen("/bin/fp_control -tm 1")
+		except OSError:
+			print "no memory"
+
+	def disableTimeMode(self):
+		self.timeModeEnabled = 0
+		try:
+			os.popen("/bin/fp_control -tm 0")
+		except OSError:
+			print "no memory"
+
+	def enableLed(self):
+		self.ledEnabled = True
+		try:
+			os.popen("/bin/fp_control -l 0 1")
+		except OSError:
+			print "no memory"
+
+	def disableLed(self):
+		self.ledEnabled = False
+		try:
+			os.popen("/bin/fp_control -l 0 0")
+		except OSError:
+			print "no memory"
+
+	def enableFan(self):
+		self.fanEnabled = True
+		try:
+			os.popen("/bin/fp_control -sf 1")
+		except OSError:
+			print "no memory"
+
+	def disableFan(self):
+		self.fanEnabled = False
+		try:
+			os.popen("/bin/fp_control -sf 0")
+		except OSError:
+			print "no memory"
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		tmp = self.getTimeshiftState()
+		if tmp == self.tsEnabled:
+			return
+		if tmp:
+			print "[Timeshift enabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,True)
+		else:
+			print "[Timeshift disabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,False)
+		self.tsEnabled = tmp
+		
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "CuberevoVFD aborting"
+
+def main(session, **kwargs):
+	session.open(CuberevoVFDSetup)
+
+cubeVfd = None
+gReason = -1
+mySession = None
+
+def controlcubeVfd():
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and cubeVfd == None:
+		print "Starting CuberevoVFD"
+		cubeVfd = CuberevoVFD(mySession)
+	elif gReason == 1 and cubeVfd != None:
+		print "Stopping CuberevoVFD"
+		cubeVfd = None
+
+def autostart(reason, **kwargs):
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlcubeVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="CuberevoVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/Extensions/Makefile.am enigma2-nightly/lib/python/Plugins/Extensions/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/Makefile.am	2013-01-31 12:39:33.652182808 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/Makefile.am	2013-01-31 12:39:33.992182821 +0100
@@ -1,6 +1,14 @@
 installdir = $(pkglibdir)/python/Plugins/Extensions
 
-SUBDIRS = TuxboxPlugins CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn Modem
+SUBDIRS = CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn
+
+if ENABLE_TF7700
+SUBDIRS += TopfieldVFD
+endif
+
+if ENABLE_CUBEREVO
+SUBDIRS += CuberevoVFD
+endif
 
 if HAVE_LIBDDVD
 SUBDIRS += DVDPlayer
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	2013-01-31 12:39:33.992182821 +0100
@@ -0,0 +1,2 @@
+
+
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	2013-01-31 12:39:33.992182821 +0100
@@ -0,0 +1,5 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/TopfieldVFD
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	2013-01-31 12:39:33.992182821 +0100
@@ -0,0 +1,458 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, ConfigSubsection, ConfigEnableDisable, \
+	getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time, fcntl, struct
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from enigma import eTimer
+from re import compile as re_compile, search as re_search
+from time import time, localtime, strftime
+from Components.UsageConfig import defaultMoviePath
+from os import statvfs
+import array
+
+my_global_session = None
+debug = False
+
+config.plugins.TopfieldVFD = ConfigSubsection()
+config.plugins.TopfieldVFD.allCaps = ConfigEnableDisable(default = False)
+config.plugins.TopfieldVFD.scroll = ConfigSelection(choices = [("never"), ("once"), ("always")])
+config.plugins.TopfieldVFD.brightness = ConfigSelection(default = "medium", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.TopfieldVFD.scrollPause = ConfigInteger(default = 100, limits = (1, 255))
+config.plugins.TopfieldVFD.scrollDelay = ConfigInteger(default = 10, limits = (1, 255))
+config.plugins.TopfieldVFD.typematicDelay = ConfigInteger(default = 3, limits = (0, 255))
+config.plugins.TopfieldVFD.typematicRate = ConfigInteger(default = 10, limits = (0, 255))
+config.plugins.TopfieldVFD.rcCommandSet = ConfigSelection(default = "TF7700 & Masterpiece", choices = [("TF7700"), ("Masterpiece"), ("TF7700 & Masterpiece")])
+config.plugins.TopfieldVFD.showClock = ConfigEnableDisable(default = True)
+config.plugins.TopfieldVFD.showEthernet = ConfigEnableDisable(default = True)
+
+# ioctl definitions for the VFD
+ioBootReason = 0x40003a0b
+ioOffFlush = struct.pack('LLB', 0x2, 0x0, 0x6)
+ioRec1Flush = struct.pack('LLB', 0x1000, 0x0, 0x6)
+ioRec2Flush = struct.pack('LLB', 0x2000, 0x0, 0x6)
+ioRecBothFlush = struct.pack('LLB', 0x3000, 0x0, 0x6)
+ioClockFlush = struct.pack('LLB', 0x20, 0x0, 0x6)
+ioClockOff = struct.pack('LLB', 0x20, 0x0, 0x0)
+ioHddClear =    struct.pack('LLB', 0x0, 0xff8000,0x0)
+ioHddUsage = (  struct.pack('LLB', 0x0, 0x006000,0xf),  # HDD empty
+                struct.pack('LLB', 0x0, 0x00e000,0xf),
+                struct.pack('LLB', 0x0, 0x01e000,0xf),
+                struct.pack('LLB', 0x0, 0x03e000,0xf),
+                struct.pack('LLB', 0x0, 0x07e000,0xf),
+                struct.pack('LLB', 0x0, 0x0fe000,0xf),
+                struct.pack('LLB', 0x0, 0x1fe000,0xf),
+                struct.pack('LLB', 0x0, 0x3fe000,0xf),
+                struct.pack('LLB', 0x0, 0x7fe000,0xf))  # HDD full
+ioHddFull = struct.pack('LLB', 0x0, 0x800000,0x6)       # "HDD full" flashing
+hddCheckPeriod = 60 # check every 60 seconds
+ioIconCmd = 0x400b3a20
+ioTimeshiftOn = struct.pack('LLB', 0x80, 0x0, 0xf)
+ioTimeshiftOff = struct.pack('LLB', 0x80, 0x0, 0x0)
+ioRec1On = struct.pack('LLB', 0x1000, 0x0, 0xf)
+ioRec1Off = struct.pack('LLB', 0x1000, 0x0, 0x0)
+ioRec2On = struct.pack('LLB', 0x2000, 0x0, 0xf)
+ioRec2Off = struct.pack('LLB', 0x2000, 0x0, 0x0)
+ioRecBothOn = struct.pack('LLB', 0x3000, 0x0, 0xf)
+ioRecBothOff = struct.pack('LLB', 0x3000, 0x0, 0x0)
+ioEthBothOff = struct.pack('LLB', 0x0c000000, 0x0, 0x0)
+ioEthLeftOn = struct.pack('LLB', 0x08000000, 0x0, 0xe)
+ioEthRightOn = struct.pack('LLB', 0x04000000, 0x0,0xb)
+
+ioColonOn = struct.pack('LLB', 0x4, 0x0,0x3)
+ioColonOff = struct.pack('LLB', 0x4, 0x0,0x0)
+ioBrightnessCmd = 0x40013a05
+ioIrFilter1Cmd = 0x40003a06
+ioIrFilter4Cmd = 0x40003a09
+ioTypematicDelayCmd = 0x40013a0d
+ioTypematicRateCmd = 0x40013a0e
+ioScrollModeCmd = 0x40033a15
+ioAllcapsCmd = 0x40013a14
+
+class TopfieldVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="TopfieldVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.TopfieldVFD.showClock))
+		self.list.append(getConfigListEntry(_("Show Ethernet activity"), config.plugins.TopfieldVFD.showEthernet))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.TopfieldVFD.brightness))
+		self.list.append(getConfigListEntry(_("All caps"), config.plugins.TopfieldVFD.allCaps))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.TopfieldVFD.scroll))
+		self.list.append(getConfigListEntry(_("Scroll pause"), config.plugins.TopfieldVFD.scrollPause))
+		self.list.append(getConfigListEntry(_("Scroll delay"), config.plugins.TopfieldVFD.scrollDelay))
+		self.list.append(getConfigListEntry(_("Typematic delay"), config.plugins.TopfieldVFD.typematicDelay))
+		self.list.append(getConfigListEntry(_("Typematic rate"), config.plugins.TopfieldVFD.typematicRate))
+		self.list.append(getConfigListEntry(_("RC command set"), config.plugins.TopfieldVFD.rcCommandSet))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+			}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+		tfVfd.setValues()
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+class TopfieldVFD:
+	def __init__(self, session):
+		#print "TopfieldVFD initializing"
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+		{
+			iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+			iPlayableService.evStart: self.__evStart,
+		})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.Console = Console()
+		self.tsEnabled = False
+		self.recNum = 0
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+		self.txCount = 0
+		self.clock = 0
+		self.valuesSet = 0
+		self.hddUsed = 10 # initialize with an invalid value
+		self.hddCheckCounter = hddCheckPeriod
+		self.ethEnabled = config.plugins.TopfieldVFD.showEthernet.getValue()
+		self.clockEnabled = config.plugins.TopfieldVFD.showClock.getValue()
+		self.setValues()
+
+	def setValues(self):
+		#print "\nTopfiledVFD.setValues()\n"
+		if config.plugins.TopfieldVFD.showClock.value:
+			self.enableClock()
+		else:
+			self.disableClock()
+
+		# enable/disable displaying Ethernet activity
+		if config.plugins.TopfieldVFD.showEthernet.getValue():
+			self.enableEthernet()
+		else:
+			self.disableEthernet()
+
+		try:
+			fd = open("/dev/fpc")
+
+			# set the brightness
+			brightness = 3
+			if config.plugins.TopfieldVFD.brightness.getValue() == "dark":
+				brightness = 1
+			elif config.plugins.TopfieldVFD.brightness.getValue() == "bright":
+				brightness = 5
+			fcntl.ioctl(fd.fileno(), ioBrightnessCmd, struct.pack('B', brightness))
+
+			# set the the scroll mode
+			if config.plugins.TopfieldVFD.scroll.value == "once":
+				scrollMode = 1
+			elif config.plugins.TopfieldVFD.scroll.value == "always":
+				scrollMode = 2
+			else: # set to never by default
+				scrollMode = 0
+			scrollOpts = struct.pack('BBB', scrollMode,
+						int(config.plugins.TopfieldVFD.scrollPause.value),
+						int(config.plugins.TopfieldVFD.scrollDelay.value))
+			fcntl.ioctl(fd.fileno(), ioScrollModeCmd, scrollOpts)
+
+			# set the typematic values
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicRate.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicRateCmd, tmp)
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicDelay.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicDelayCmd, tmp)
+
+			# set the IR filters
+			if config.plugins.TopfieldVFD.rcCommandSet.getValue() == "Masterpiece":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 0))
+			elif config.plugins.TopfieldVFD.rcCommandSet.getValue() == "TF7700":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 0))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+			else: # enable both by default
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+
+			# set the allcaps parameter
+			if config.plugins.TopfieldVFD.allCaps.value:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 1))
+			else:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 0))
+
+			buf = array.array('h', [0])
+			fcntl.ioctl(fd.fileno(),ioBootReason,buf,1)
+			if buf[0] == 2:
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioOffFlush)
+
+			fd.close()
+			self.valuesSet = 1
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: setValues ", e
+
+	def enableEthernet(self):
+		self.ethEnabled = True
+
+	def disableEthernet(self):
+		self.ethEnabled = False
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: disableEthernet ", e
+
+	def enableClock(self):
+		self.clockEnabled = True
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOn)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: enableClock ", e
+
+	def disableClock(self):
+		self.clockEnabled = False
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOff)
+			fd.close()
+			open("/dev/fpsmall", "w").write("     ")
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: disableClock ", e
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+
+	def displayHddUsed(self):
+		if debug:
+			print "TopfieldVFD: determine HDD usage"
+
+		# determine the HDD usage
+		used = 0;
+		try:
+			f = statvfs(defaultMoviePath())
+			# there are 8 HDD segments in the VFD
+			used = (f.f_blocks - f.f_bavail) * 8 / f.f_blocks
+		except:
+			used = 0;
+
+		if self.hddUsed != used:
+			try:
+				fd = open("/dev/fpc")
+				if self.hddUsed > used:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddClear)
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddUsage[used])
+				if used == 8:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddFull)
+				fd.close();
+			except IOError,e:
+				self.hddUsed = used # dummy operation
+			self.hddUsed = used
+
+	def handleTimer(self):
+		#print "[ TopfieldVFD timer ]"
+		if self.valuesSet == 0:
+			self.setValues()
+
+		if self.clockEnabled:
+			clock = strftime("%k%M",localtime(time()))
+			if clock != self.clock:
+				self.clock = clock
+				try:
+					open("/dev/fpsmall", "w").write(clock + "\0")
+				except IOError,e:
+					if debug:
+						print "TopfieldVFD: handleTimer (clock) ", e
+
+		# check HDD periodically
+		if self.hddCheckCounter < hddCheckPeriod:
+			self.hddCheckCounter += 1
+		else:
+			self.hddCheckCounter = 0
+			self.displayHddUsed()
+
+		if self.ethEnabled == False:
+			return
+
+		result = open("/proc/net/dev").readlines()
+		numRegExp = "[0-9]+"
+		numPattern = re_compile(numRegExp)
+		txPattern = re_compile("eth0:[ ]*" + numRegExp)
+		for item in result:
+			tmp = self.regExpMatch(txPattern, item)
+			if tmp != None:
+				tmp = tmp[5:].lstrip()
+				try:
+					fd = open("/dev/fpc")
+					if self.txCount != tmp:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthLeftOn)
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthRightOn)
+						self.txCount = tmp
+					else:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+					fd.close()
+				except IOError,e:
+					if debug:
+						print "TopfieldVFD: handleTimer (Ethernet) ", e
+					break
+
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		tmp = self.getTimeshiftState()
+		if tmp == self.tsEnabled:
+			return
+		try:
+			fd = open("/dev/fpc")
+			if tmp:
+				print "[Timeshift enabled]"
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOn)
+			else:
+				print "[Timeshift disabled]"
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOff)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: __evSeekableStatusChanged ", e
+			self.tsEnabled = tmp
+
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs == self.recNum:
+			return
+		try:
+			fd = open("/dev/fpc")
+			if config.usage.blinking_display_clock_during_recording.value:
+				if nrecs > 1: # set rec 1+2 symbols
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothFlush)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+				elif nrecs > 0: # set rec 1 symbol
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1Flush)
+				else:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+			else:
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+				if nrecs > 1: # set rec 1+2 symbols
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOn)
+				elif nrecs > 0: # set rec 1 symbol
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1On)
+				else:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: gotRecordEvent ", e
+		self.recNum = nrecs
+
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "TopfieldVFD aborting"
+
+def main(session, **kwargs):
+	session.open(TopfieldVFDSetup)
+
+tfVfd = None
+gReason = -1
+mySession = None
+
+def controlTfVfd():
+	global tfVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and tfVfd == None:
+		print "Starting TopfieldVFD"
+		tfVfd = TopfieldVFD(mySession)
+	elif gReason == 1 and tfVfd != None:
+		print "Stopping TopfieldVFD"
+		tfVfd.disableClock()
+		tfVfd = None
+
+def autostart(reason, **kwargs):
+	global tfVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlTfVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="TopfieldVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py enigma2-nightly/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py	2013-01-31 12:39:33.660182808 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py	2013-01-31 12:39:33.996182822 +0100
@@ -9,6 +9,8 @@
 	action = v.get("ACTION")
 	device = v.get("DEVPATH")
 	physdevpath = v.get("PHYSDEVPATH")
+	if physdevpath == "-":
+		physdevpath = None
 	media_state = v.get("X_E2_MEDIA_STATUS")
 
 	dev = device.split('/')[-1]

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py enigma2-nightly/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py	2013-01-31 12:39:33.672182808 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py	2013-01-31 12:39:33.996182822 +0100
@@ -10,7 +10,7 @@
 from Components.MenuList import MenuList
 from Plugins.Plugin import PluginDescriptor
 from Components.config import config
-from Tools.Directories import resolveFilename, SCOPE_PLUGINS
+from Tools.Directories import resolveFilename, SCOPE_PLUGINS, SCOPE_SKIN
 from os import path, walk
 from enigma import eEnv
 
@@ -85,7 +85,7 @@
 		for x in names:
 			if x == "skin.xml":
 				if dirname <> self.root:
-					subdir = dirname[19:]
+					subdir = dirname[len(resolveFilename(SCOPE_SKIN)):]
 					self.skinlist.append(subdir)
 				else:
 					subdir = "Default Skin"
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	2013-01-31 12:39:33.996182822 +0100
@@ -0,0 +1,2 @@
+
+
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	2013-01-31 12:39:33.996182822 +0100
@@ -0,0 +1,9 @@
+This plugin is licensed under the Creative Commons 
+Attribution-NonCommercial-ShareAlike 3.0 Unported 
+License. To view a copy of this license, visit
+http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative
+Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
+
+This plugin is NOT free software. It is open source, you are allowed to
+modify it (if you keep the license), but it may not be commercially 
+distributed other than under the conditions noted above.
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	2013-01-31 12:39:33.996182822 +0100
@@ -0,0 +1,9 @@
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/VFD-Icons
+
+SUBDIRS = meta
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
+
+dist_install_DATA = LICENSE
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	2013-01-31 12:39:33.996182822 +0100
@@ -0,0 +1,3 @@
+installdir = $(datadir)/meta
+
+dist_install_DATA = plugin_vfd-icons.xml
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	2013-01-31 12:39:33.996182822 +0100
@@ -0,0 +1,20 @@
+<default>
+	<prerequisites>
+		<hardware type="dm8000" />
+		<tag type="System" />
+	</prerequisites>
+	<info>
+		<author>Team Ducktales</author>
+		<name>VFD-Icons</name>
+		<packagename>enigma2-plugin-systemplugins-vfd-icons</packagename>
+		<packagetype>public</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+		<shortdescription>Displays text on vfd</shortdescription>
+		<description>Displays text on vfd.
+		</description>
+	</info>
+
+	<files type="package"> <!-- without version, without .ipk -->
+		<file type="package" name="enigma2-plugin-systemplugins-vfd-icons" />
+	</files>
+
+</default>
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	2013-01-31 12:39:33.996182822 +0100
@@ -0,0 +1,152 @@
+# -*- coding: utf-8 -*-
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+
+class VFDIcons:
+	def __init__(self, session):
+		# Save Session&Servicelist, Create Timer, Init Services
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evUpdatedInfo: self.__evUpdatedInfo,
+				iPlayableService.evUpdatedEventInfo: self.__evUpdatedEventInfo,
+				iPlayableService.evVideoSizeChanged: self.__evVideoSizeChanged,
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.mp3Available = False
+		self.dolbyAvailable = False
+		
+	def __evStart(self):
+		print "[__evStart]"
+		self.__evSeekableStatusChanged()
+
+	def __evUpdatedInfo(self):
+		print "[__evUpdatedInfo]"
+		self.checkAudioTracks()
+		self.writeChannelName()
+		self.showCrypted()
+		self.showDolby()
+		self.showMp3()
+
+	def writeChannelName(self):
+		print "[writeChannelName]"
+		servicename = ""
+		currPlay = self.session.nav.getCurrentService()
+		if currPlay != None and self.mp3Available:
+			# show the MP3 tag
+			servicename = currPlay.info().getInfoString(iServiceInformation.sTagTitle)
+		else:
+			# show the service name
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename = subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+			else:
+				print "no Service found"
+
+		print "vfd display text:", servicename[0:63]
+		evfd.getInstance().vfd_write_string(servicename[0:63])
+		return 1
+
+	def showCrypted(self):
+		print "[showCrypted]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			crypted = info and info.getInfo(iServiceInformation.sIsCrypted) or -1
+			if crypted == 1 : #set crypt symbol
+				evfd.getInstance().vfd_set_icon(0x13,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x13,0)
+
+	def checkAudioTracks(self):
+		self.dolbyAvailable = False
+		self.mp3Available = False
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			audio = service.audioTracks()
+			if audio:
+				n = audio.getNumberOfTracks()
+				for x in range(n):
+					i = audio.getTrackInfo(x)
+					description = i.getDescription();
+					if description.find("MP3") != -1:
+						self.mp3Available = True
+					if description.find("AC3") != -1 or description.find("DTS") != -1:
+						self.dolbyAvailable = True
+
+	def showDolby(self):
+		print "[showDolby]"
+		if self.dolbyAvailable:
+			evfd.getInstance().vfd_set_icon(0x17,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x17,0)
+
+	def showMp3(self):
+		print "[showMp3]"
+		if self.mp3Available:
+			evfd.getInstance().vfd_set_icon(0x15,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x15,0)
+
+	def __evUpdatedEventInfo(self):
+		print "[__evUpdatedEventInfo]"
+
+	def getSeekState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		seek = service.seek()
+		if seek is None:
+			return False
+		return seek.isCurrentlySeekable()
+
+	def __evSeekableStatusChanged(self):
+		print "[__evSeekableStatusChanged]"
+		if self.getSeekState():
+			evfd.getInstance().vfd_set_icon(0x1A,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1A,0)
+
+	def __evVideoSizeChanged(self):
+		print "[__evVideoSizeChanged]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			height = info and info.getInfo(iServiceInformation.sVideoHeight) or -1
+			if height > 576 : #set HD symbol
+				evfd.getInstance().vfd_set_icon(0x11,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x11,0)
+
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs > 0: #set rec symbol
+			evfd.getInstance().vfd_set_icon(0x1e,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1e,0)
+
+VFDIconsInstance = None
+
+def main(session, **kwargs):
+	# Create Instance if none present, show Dialog afterwards
+	global VFDIconsInstance
+	if VFDIconsInstance is None:
+		VFDIconsInstance = VFDIcons(session)
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="VFDIcons", description="Icons in VFD", where = PluginDescriptor.WHERE_SESSIONSTART, fnc=main ) ]
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2013-01-31 12:39:33.680182809 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2013-01-31 12:39:33.996182822 +0100

@@ -90,6 +93,14 @@
 
 #		if config.av.videoport.value == "DVI":
 #			self.list.append(getConfigListEntry(_("Allow Unsupported Modes"), config.av.edid_override))
+#+++>
+		if config.av.videoport.value == "Component":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_yuv))
+
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_hdmi))
+			self.list.append(getConfigListEntry(_("Audio Source"), config.av.hdmi_audio_source))
+#+++<
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color format"), config.av.colorformat, _("Configure which color format should be used on the SCART output.")))
 			if level >= 1:
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2013-01-31 12:39:33.676182808 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2013-01-31 12:39:33.996182822 +0100

@@ -125,6 +106,16 @@
 		config.av.wss.notifiers = [ ]
 		AVSwitch.getOutputAspect = self.getOutputAspect
 
+#+++>
+		config.av.colorformat_hdmi = ConfigSelection(choices = {"hdmi_rgb": _("RGB"), "hdmi_yuv": _("YUV"), "hdmi_422": _("422")}, default="hdmi_rgb")
+		config.av.colorformat_yuv = ConfigSelection(choices = {"yuv": _("YUV")}, default="yuv")
+		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF")}, default="pcm")
+		config.av.threedmode = ConfigSelection(choices = {"off": _("Off"), "sbs": _("Side by Side"),"tab": _("Top and Bottom")}, default="off")
+		config.av.threedmode.addNotifier(self.set3DMode)
+		config.av.colorformat_hdmi.addNotifier(self.setHDMIColor)
+		config.av.colorformat_yuv.addNotifier(self.setYUVColor)
+		config.av.hdmi_audio_source.addNotifier(self.setHDMIAudioSource)
+#+++<
 		config.av.aspect.addNotifier(self.updateAspect)
 		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)

@@ -192,7 +185,12 @@
 		except IOError:
 			print "writing initial videomode to /etc/videomode failed."
 
+		#call setResolution() with -1,-1 to read the new scrren dimesions without changing the framebuffer resolution
+		from enigma import gMainDC
+		gMainDC.getInstance().setResolution(-1, -1)
+
 		self.updateAspect(None)
+		self.updateColor(port)
 
 	def saveMode(self, port, mode, rate):
 		print "saveMode", port, mode, rate
@@ -210,7 +208,8 @@
 		return True
 
 	def isPortUsed(self, port):
-		if port == "DVI":
+#		if port == "DVI":
+		if port == "HDMI":
 			self.readPreferredModes()
 			return len(self.modes_preferred) != 0
 		else:
@@ -344,6 +343,33 @@
 		except IOError:
 			pass
 
+#+++>
+	def set3DMode(self, configElement):
+		open("/proc/stb/video/3d_mode", "w").write(configElement.value)
+
+	def setHDMIColor(self, configElement):
+		map = {"hdmi_rgb": 0, "hdmi_yuv": 1, "hdmi_422": 2}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setYUVColor(self, configElement):
+		map = {"yuv": 0}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setHDMIAudioSource(self, configElement):
+		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
+
+	def updateColor(self, port):
+		print "updateColor: ", port
+		if port == "HDMI":
+			self.setHDMIColor(config.av.colorformat_hdmi)
+		elif port == "Component":
+			self.setYUVColor(config.av.colorformat_yuv)
+		elif port == "Scart":
+			map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
+			from enigma import eAVSwitch
+			eAVSwitch.getInstance().setColorFormat(map[config.av.colorformat.value])
+#+++<
+
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
 video_hw.setConfiguredMode()
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Screens/ChannelSelection.py enigma2-nightly/lib/python/Screens/ChannelSelection.py
--- enigma2-nightly.org/lib/python/Screens/ChannelSelection.py	2013-01-31 12:39:33.680182809 +0100
+++ enigma2-nightly/lib/python/Screens/ChannelSelection.py	2013-01-31 12:39:33.996182822 +0100
@@ -3,6 +3,11 @@
 from Screen import Screen
 from Components.Button import Button
 from Components.ServiceList import ServiceList
+#+++>
+from Components.Sources.StaticText import StaticText
+from Components.Label import Label
+from os import path as os_path, system, unlink
+#+++<
 from Components.ActionMap import NumberActionMap, ActionMap, HelpableActionMap
 from Components.MenuList import MenuList
 from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
@@ -462,7 +467,9 @@
 		self.__marked = [ ]
 		self.saved_title = None
 		self.saved_root = None
-
+#+++>
+		self["title"] = StaticText()
+#+++<
 		class ChannelSelectionEditActionMap(ActionMap):
 			def __init__(self, csel, contexts = [ ], actions = { }, prio=0):
 				ActionMap.__init__(self, contexts, actions, prio)
@@ -655,6 +662,9 @@
 			else:
 				new_title += ' ' + _("[favourite edit]")
 		self.setTitle(new_title)
+#+++>
+		self["title"].setText(new_title)
+#+++<
 		self.__marked = self.servicelist.getRootServices()
 		for x in self.__marked:
 			self.servicelist.addMarked(eServiceReference(x))
@@ -680,6 +690,9 @@
 		self.bouquet_mark_edit = OFF
 		self.mutableList = None
 		self.setTitle(self.saved_title)
+#+++>
+		self["title"].setText(self.saved_title)
+#+++<
 		self.saved_title = None
 		# self.servicePath is just a reference to servicePathTv or Radio...
 		# so we never ever do use the asignment operator in self.servicePath
@@ -733,6 +746,9 @@
 			self.mutableList.flushChanges() # FIXME add check if changes was made
 			self.mutableList = None
 			self.setTitle(self.saved_title)
+#+++>
+			self["title"].setText(self.saved_title)
+#+++<
 			self.saved_title = None
 			cur_root = self.getRoot()
 			self.servicelist.resetRoot()
@@ -745,6 +761,9 @@
 			pos = self.saved_title.find(')')
 			new_title = self.saved_title[:pos+1] + ' ' + _("[move mode]") + self.saved_title[pos+1:]
 			self.setTitle(new_title);
+#+++>
+			self["title"].setText(new_title)
+#+++<
 
 	def handleEditCancel(self):
 		if self.movemode: #movemode active?
@@ -796,6 +815,11 @@
 		self["list"] = ServiceList()
 		self.servicelist = self["list"]
 
+#+++>
+		self["boquet"] = Label(_("Channel Selection"))
+		self["title"] = StaticText()
+#+++<
+
 		self.numericalTextInput = NumericalTextInput()
 		self.numericalTextInput.setUseableChars(u'1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
 
@@ -880,6 +904,9 @@
 			title = title[:pos]
 		title += _(" (TV)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRadioMode(self):
 		self.mode = MODE_RADIO
@@ -891,6 +918,9 @@
 			title = title[:pos]
 		title += _(" (Radio)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRoot(self, root, justSet=False):
 		if self.startRoot is None:

@@ -953,7 +986,13 @@
 						titleStr += '/'
 					nameStr = self.getServiceName(end_ref)
 					titleStr += nameStr
+#+++>
+					self["boquet"].setText(nameStr)
+#+++<
 				self.setTitle(titleStr)
+#+++>
+				self["title"].setText(titleStr)
+#+++<
 
 	def moveUp(self):
 		self.servicelist.moveUp()
@@ -1786,6 +1825,9 @@
 
 	def layoutFinished(self):
 		self.setModeTv()
+#+++>
+		self["title"].setText(self.title)
+#+++<
 
 	def channelSelected(self): # just return selected service
 		ref = self.getCurrentSelection()
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py enigma2-nightly/lib/python/Screens/InfoBarGenerics.py
--- enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py	2013-01-31 12:39:33.680182809 +0100
+++ enigma2-nightly/lib/python/Screens/InfoBarGenerics.py	2013-01-31 12:39:33.996182822 +0100
@@ -8,7 +8,7 @@
 from Components.PluginComponent import plugins
 from Components.ServiceEventTracker import ServiceEventTracker
 from Components.Sources.Boolean import Boolean
-from Components.config import config, ConfigBoolean, ConfigClock
+from Components.config import config, ConfigBoolean, ConfigClock, ConfigSubsection, ConfigYesNo, ConfigText
 from Components.SystemInfo import SystemInfo
 from Components.UsageConfig import preferredInstantRecordPath, defaultMoviePath, ConfigSelection
 from EpgSelection import EPGSelection
@@ -31,6 +31,7 @@
 
 from Tools import Notifications
 from Tools.Directories import fileExists
+from Tools.Command import command
 
 from enigma import eTimer, eServiceCenter, eDVBServicePMTHandler, iServiceInformation, \
 	iPlayableService, eServiceReference, eEPGCache, eActionMap

@@ -166,6 +167,7 @@
 	STATE_HIDING = 1
 	STATE_SHOWING = 2
 	STATE_SHOWN = 3
+	STATE_EPG = 4
 
 	def __init__(self):
 		self["ShowHideActions"] = ActionMap( ["InfobarShowHideActions"] ,
@@ -253,6 +255,12 @@
 		if self.__state == self.STATE_SHOWN:
 			self.hide()
 
+	def epg(self):
+		self.__state = self.STATE_EPG
+		self.hide()
+		self.hideTimer.stop()
+		self.openEventView()
+
 	def toggleShow(self):
 		if self.__state == self.STATE_HIDDEN:
 			self.show()

@@ -1538,7 +1548,7 @@
 
 	def updateExtensions(self):
 		self.extensionsList = []
-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+		self.availableKeys = [ "red", "green", "yellow", "blue", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ]
 		self.extensionKeys = {}
 		for x in self.list:
 			if x[0] == self.EXTENSION_SINGLE:

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Screens/InfoBar.py enigma2-nightly/lib/python/Screens/InfoBar.py
--- enigma2-nightly.org/lib/python/Screens/InfoBar.py	2013-01-31 12:39:33.680182809 +0100
+++ enigma2-nightly/lib/python/Screens/InfoBar.py	2013-01-31 12:39:33.996182822 +0100

@@ -35,7 +38,7 @@
 	InfoBarSubserviceSelection, InfoBarTimeshift, InfoBarSeek,
 	InfoBarSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions,
 	InfoBarPiP, InfoBarPlugins, InfoBarSubtitleSupport, InfoBarServiceErrorPopupSupport, InfoBarJobman,
-	Screen):
+	InfoBarAspectSelection, InfoBarSleepTimer, Screen):
 	
 	ALLOW_SUSPEND = True
 	instance = None
@@ -47,6 +50,11 @@
 				"showMovies": (self.showMovies, _("Play recorded movies...")),
 				"showRadio": (self.showRadio, _("Show the radio player...")),
 				"showTv": (self.showTv, _("Show the tv player...")),
+				"toogleTvRadio": (self.toogleTvRadio, _("toggels betwenn tv and radio...")),
+				"volumeUp": (self._volUp, _("...")),
+				"volumeDown": (self._volDown, _("...")),
+				"resolution": (self.resolution, _("...")),
+				"aspect": (self.aspect, _("...")),
 			}, prio=2)
 		
 		self.allowPiP = True
@@ -58,7 +66,7 @@
 				InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarSubserviceSelection, \
 				InfoBarTimeshift, InfoBarSeek, InfoBarSummarySupport, InfoBarTimeshiftState, \
 				InfoBarTeletextPlugin, InfoBarExtensions, InfoBarPiP, InfoBarSubtitleSupport, InfoBarJobman, \
-				InfoBarPlugins, InfoBarServiceErrorPopupSupport:
+				InfoBarAspectSelection, InfoBarSleepTimer, InfoBarPlugins, InfoBarServiceErrorPopupSupport:
 			x.__init__(self)
 
 		self.helpList.append((self["actions"], "InfobarActions", [("showMovies", _("Watch recordings..."))]))
@@ -73,6 +81,88 @@
 		assert InfoBar.instance is None, "class InfoBar is a singleton class and just one instance of this class is allowed!"
 		InfoBar.instance = self
 
+	def aspect(self):
+		selection = 0
+		tlist = []
+		try:
+			policy = open("/proc/stb/video/policy_choices").read()[:-1]
+		except IOError:
+			print "couldn't read available policymodes."
+			policy_available = [ ]
+			return
+		policy_available = policy.split(' ')
+		for x in policy_available:
+			tlist.append((x[0].upper() + x[1:], _(x)))
+
+		mode = open("/proc/stb/video/policy").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+
+		keys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.aspectSelect, ChoiceBox, title=_("Please select an aspect ratio..."), list = tlist, selection = selection, keys = keys)
+
+	def aspectSelect(self, aspect):
+		if not aspect is None:
+			if isinstance(aspect[1], str):
+				open("/proc/stb/video/policy", "w").write(aspect[1])
+		return
+
+	def resolution(self):
+		xresString = open("/proc/stb/vmpeg/0/xres", "r").read()
+		yresString = open("/proc/stb/vmpeg/0/yres", "r").read()
+		fpsString = open("/proc/stb/vmpeg/0/framerate", "r").read()
+		xres = int(xresString, 16)
+		yres = int(yresString, 16)
+		fps = int(fpsString, 16)
+		fpsFloat = float(fps)
+		fpsFloat = fpsFloat/1000
+
+		selection = 0
+		tlist = []
+		tlist.append(("Video: " + str(xres) + "x" + str(yres) + "@" + str(fpsFloat) + "hz", ""))
+		tlist.append(("--", ""))
+		tlist.append(("576i", "576i50"))
+		tlist.append(("576p", "576p50"))
+		tlist.append(("720p@50hz", "720p50"))
+		tlist.append(("720p@60hz", "720p60"))
+		tlist.append(("1080i@50hz", "1080i50"))
+		tlist.append(("1080i@60hz", "1080i60"))
+		tlist.append(("1080p@23.976hz", "1080p23"))
+		tlist.append(("1080p@24hz", "1080p24"))
+		tlist.append(("1080p@25hz", "1080p25"))
+		tlist.append(("1080p@30hz", "1080p30"))
+		tlist.append(("1080p@50hz", "1080p50"))
+		tlist.append(("1080p@59hz", "1080p59"))
+		tlist.append(("1080p@60hz", "1080p60"))
+		keys = ["green", "", "yellow", "blue", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+
+		mode = open("/proc/stb/video/videomode").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.ResolutionSelect, ChoiceBox, title=_("Please select a resolution..."), list = tlist, selection = selection, keys = keys)
+
+	def ResolutionSelect(self, Resolution):
+		if not Resolution is None:
+			if isinstance(Resolution[1], str):
+				open("/proc/stb/video/videomode", "w").write(Resolution[1])
+				from enigma import gMainDC
+				gMainDC.getInstance().setResolution(-1, -1)
+		return
+
+	def _volUp(self):
+		print "_volUp"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volUp()
+
+	def _volDown(self):
+		print "_volDown"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volDown()
+
 	def __onClose(self):
 		InfoBar.instance = None
 
@@ -91,6 +181,22 @@
 		self.__serviceStarted(True)
 		self.onExecBegin.remove(self.__checkServiceStarted)
 
+	def toogleTvRadio(self): 
+		service = self.session.nav.getCurrentService()
+		info = service.info()
+		AudioPID = info.getInfo(iServiceInformation.sAudioPID)
+		VideoPID = info.getInfo(iServiceInformation.sVideoPID)
+
+		print "sAudioPID", AudioPID
+		print "sVideoPID", VideoPID
+
+		if VideoPID == -1:
+			print "radio->tv"
+			self.showTv2()
+		else:
+			print "tv->radio"
+			self.showRadio2()
+
 	def serviceStarted(self):  #override from InfoBarShowHide
 		new = self.servicelist.newServicePlayed()
 		if self.execing:
@@ -114,6 +220,19 @@
 			from Screens.ChannelSelection import ChannelSelectionRadio
 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
 
+	def showTv2(self):
+		self.showTvChannelList(False)
+		self.openServiceList()
+
+	def showRadio2(self):
+		if config.usage.e1like_radio_mode.value:
+			self.showRadioChannelList(False)
+			self.openServiceList()
+		else:
+			self.rds_display.hide() # in InfoBarRdsDecoder
+			from Screens.ChannelSelection import ChannelSelectionRadio
+			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
+
 	def ChannelSelectionRadioClosed(self, *arg):
 		self.rds_display.show()  # in InfoBarRdsDecoder
 
@@ -135,6 +254,7 @@
 		InfoBarSeek, InfoBarShowMovies, InfoBarAudioSelection, HelpableScreen, InfoBarNotifications,
 		InfoBarServiceNotifications, InfoBarPVRState, InfoBarCueSheetSupport, InfoBarSimpleEventView,
 		InfoBarMoviePlayerSummarySupport, InfoBarSubtitleSupport, Screen, InfoBarTeletextPlugin,
+		InfoBarAspectSelection, InfoBarSubserviceSelection,
 		InfoBarServiceErrorPopupSupport, InfoBarExtensions, InfoBarPlugins, InfoBarPiP):
 
 	ENABLE_RESUME_SUPPORT = True
@@ -143,6 +263,8 @@
 	def __init__(self, session, service, slist = None, lastservice = None):
 		Screen.__init__(self, session)
 		
+		InfoBarAspectSelection.__init__(self)
+
 		self["actions"] = HelpableActionMap(self, "MoviePlayerActions",
 			{
 				"leavePlayer": (self.leavePlayer, _("leave movie player...")),

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Screens/Standby.py enigma2-nightly/lib/python/Screens/Standby.py
--- enigma2-nightly.org/lib/python/Screens/Standby.py	2013-01-31 12:39:33.684182810 +0100
+++ enigma2-nightly/lib/python/Screens/Standby.py	2013-01-31 12:39:33.996182822 +0100
@@ -11,6 +11,9 @@
 class Standby(Screen):
 	def Power(self):
 		print "leave standby"
+#+++>
+		open("/proc/stb/hdmi/output", "w").write("on")
+#+++<
 		#set input to encoder
 		self.avswitch.setInput("ENCODER")
 		#restart last played service
@@ -65,6 +68,9 @@
 			self.avswitch.setInput("SCART")
 		else:
 			self.avswitch.setInput("AUX")
+#+++>
+		open("/proc/stb/hdmi/output", "w").write("off")
+#+++<
 		self.onFirstExecBegin.append(self.__onFirstExecBegin)
 		self.onClose.append(self.__onClose)
 
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Screens/Wizard.py enigma2-nightly/lib/python/Screens/Wizard.py
--- enigma2-nightly.org/lib/python/Screens/Wizard.py	2013-01-31 12:39:33.684182810 +0100
+++ enigma2-nightly/lib/python/Screens/Wizard.py	2013-01-31 12:39:33.996182822 +0100
@@ -14,6 +14,9 @@
 
 from xml.sax import make_parser
 from xml.sax.handler import ContentHandler
+#+++>
+from enigma import evfd
+#+++<
 
 class WizardSummary(Screen):
 	def __init__(self, session, parent):
@@ -351,6 +354,9 @@
 				if self.updateValues in self.onShown:
 					self.onShown.remove(self.updateValues)
 
+#+++>
+		open("/proc/progress", "w").write("100")
+#+++<
 		if print_now:
 			print "Now: " + str(self.currStep)
 
@@ -443,6 +449,9 @@
 			if self.wizard[self.currStep].has_key("onselect"):
 				self.selection = self["list"].current[-1]
 				print "self.selection:", self.selection
+#+++>
+				evfd.getInstance().vfd_write_string("-> " + self.selection)
+#+++<
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
 		
 	def resetCounter(self):
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/python/Tools/Command.py enigma2-nightly/lib/python/Tools/Command.py
--- enigma2-nightly.org/lib/python/Tools/Command.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Tools/Command.py	2013-01-31 12:39:33.996182822 +0100
@@ -0,0 +1,22 @@
+from os import stat as os_stat, path as os_path, system
+import os
+
+def command(comandline, strip=1):
+	comandline = comandline + " >/tmp/command.txt"
+	os.system(comandline)
+	text = ""
+	if os.path.exists("/tmp/command.txt") is True:
+		file = open("/tmp/command.txt", "r")
+		if strip == 1:
+			for line in file:
+				text = text + line.strip() + '\n'
+		else:
+			for line in file:
+				text = text + line
+				if text[-1:] != '\n': text = text + "\n"
+		file.close
+	if text[-1:] == '\n': text = text[:-1]
+	comandline = text
+	os.system("rm /tmp/command.txt")
+	return comandline
+

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/service/servicedvb.cpp enigma2-nightly/lib/service/servicedvb.cpp
--- enigma2-nightly.org/lib/service/servicedvb.cpp	2013-01-31 12:39:33.688182810 +0100
+++ enigma2-nightly/lib/service/servicedvb.cpp	2013-01-31 12:39:34.000182823 +0100
@@ -605,6 +605,9 @@
 	if (sc)
 	{
 		std::list<std::string> extensions;
+#if defined(__sh__) //Topfield original recording extension
+		extensions.push_back("rec");
+#endif
 		extensions.push_back("ts");
 		extensions.push_back("trp");
 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/service/servicedvbrecord.cpp enigma2-nightly/lib/service/servicedvbrecord.cpp
--- enigma2-nightly.org/lib/service/servicedvbrecord.cpp	2013-01-31 12:39:33.688182810 +0100
+++ enigma2-nightly/lib/service/servicedvbrecord.cpp	2013-01-31 12:39:34.000182823 +0100
@@ -10,6 +10,10 @@
 #include <netinet/in.h>
 
 
+#if defined(__sh__)
+#include <sys/vfs.h>
+#include <linux/magic.h>
+#endif
 DEFINE_REF(eDVBServiceRecord);
 
 eDVBServiceRecord::eDVBServiceRecord(const eServiceReferenceDVB &ref, bool isstreamclient): m_ref(ref)

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/service/servicemp3.cpp enigma2-nightly/lib/service/servicemp3.cpp
--- enigma2-nightly.org/lib/service/servicemp3.cpp	2013-01-31 12:39:33.688182810 +0100
+++ enigma2-nightly/lib/service/servicemp3.cpp	2013-01-31 12:39:34.000182823 +0100
@@ -15,8 +15,10 @@
 
 #include <string>
 
+#ifndef ENABLE_LIBEPLAYER3
 #include <gst/gst.h>
 #include <gst/pbutils/missing-plugins.h>
+#endif
 #include <sys/stat.h>
 
 #define HTTP_TIMEOUT 10


@@ -286,6 +313,7 @@
 	if (!ext)
 		ext = filename + strlen(filename);
 
+#ifndef ENABLE_LIBEPLAYER3
 	m_sourceinfo.is_video = FALSE;
 	m_sourceinfo.audiotype = atUnknown;
 	if ( (strcasecmp(ext, ".mpeg") && strcasecmp(ext, ".mpg") && strcasecmp(ext, ".vob") && strcasecmp(ext, ".bin") && strcasecmp(ext, ".dat") ) == 0 )


@@ -567,40 +820,124 @@
 RESULT eServiceMP3::pause(ePtr<iPauseableService> &ptr)
 {
 	ptr=this;
+#ifdef ENABLE_LIBEPLAYER3
+	m_event((iPlayableService*)this, evUpdatedInfo);
+#endif
 	return 0;
 }
 
+#ifdef ENABLE_LIBEPLAYER3
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+			return speed_mapping[i+1];
+		i += 2;
+	}
+	return -1;
+}
+#endif
+
 RESULT eServiceMP3::setSlowMotion(int ratio)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	if (!ratio)
 		return 0;
 	eDebug("eServiceMP3::setSlowMotion ratio=%f",1.0/(gdouble)ratio);
 	return trickSeek(1.0/(gdouble)ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
 }
 
 RESULT eServiceMP3::setFastForward(int ratio)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	eDebug("eServiceMP3::setFastForward ratio=%i",ratio);
 	return trickSeek(ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+		}
+		else
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
 }
 
 		// iPausableService
 RESULT eServiceMP3::pause()
 {
+#ifndef ENABLE_LIBEPLAYER3
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	trickSeek(0.0);
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+#endif
 
 	return 0;
 }
 
 RESULT eServiceMP3::unpause()
 {
+#ifndef ENABLE_LIBEPLAYER3
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	trickSeek(1.0);
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#endif
 
 	return 0;
 }
@@ -614,6 +951,7 @@
 
 RESULT eServiceMP3::getLength(pts_t &pts)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	if (!m_gst_playbin)
 		return -1;
 
@@ -631,11 +969,23 @@
 		/* len is in nanoseconds. we have 90 000 pts per second. */
 
 	pts = len / 11111LL;
+#else
+	double length = 0;
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+
+	if (length <= 0)
+		return -1;
+
+	pts = length * 90000;
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::seekToImpl(pts_t to)
 {
+#ifndef ENABLE_LIBEPLAYER3
 		/* convert pts to nanoseconds */
 	gint64 time_nanoseconds = to * 11111LL;
 	if (!gst_element_seek (m_gst_playbin, m_currentTrickRatio, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
@@ -645,6 +995,7 @@
 		eDebug("eServiceMP3::seekTo failed");
 		return -1;
 	}
+#endif
 
 	return 0;
 }
@@ -653,6 +1004,7 @@
 {
 	RESULT ret = -1;
 
+#ifndef ENABLE_LIBEPLAYER3
 	if (m_gst_playbin)
 	{
 		m_subtitle_pages.clear();
@@ -660,11 +1012,18 @@
 		m_decoder_time_valid_state = 0;
 		ret = seekToImpl(to);
 	}
+#else
+	float pos = (to/90000.0)-10;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
 
+	ret =0;
+#endif
 	return ret;
 }
 
 
+#ifndef ENABLE_LIBEPLAYER3
 RESULT eServiceMP3::trickSeek(gdouble ratio)
 {
 	if (!m_gst_playbin)
@@ -706,28 +1065,41 @@
 	m_decoder_time_valid_state = 0;
 	return 0;
 }
+#endif
 
 
 RESULT eServiceMP3::seekRelative(int direction, pts_t to)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	if (!m_gst_playbin)
 		return -1;
-
+#endif
 	pts_t ppos;
 	if (getPlayPosition(ppos) < 0) return -1;
 	ppos += to * direction;
 	if (ppos < 0)
 		ppos = 0;
+#ifndef ENABLE_LIBEPLAYER3
 	return seekTo(ppos);
+#else
+	float pos = direction*(to/90000.0);
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	return 0;
+#endif
 }
 
+#ifndef ENABLE_LIBEPLAYER3
 gint eServiceMP3::match_sinktype(GstElement *element, gpointer type)
 {
 	return strcmp(g_type_name(G_OBJECT_TYPE(element)), (const char*)type);
 }
+#endif
 
 RESULT eServiceMP3::getPlayPosition(pts_t &pts)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	gint64 pos;
 	pts = 0;
 
@@ -757,6 +1129,27 @@
 
 	/* pos is in nanoseconds. we have 90 000 pts per second. */
 	pts = pos / 11111LL;
+#else
+	if (player && player->playback && !player->playback->isPlaying)
+	{
+		eDebug("eServiceMP3::%s !!!!EOF!!!! < -1", __func__);
+		if(m_state == stRunning)
+			m_event((iPlayableService*)this, evEOF);
+		pts = 0;
+		return -1;
+	}
+
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+	if (vpts<=0)
+		return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+
+#endif
 	return 0;
 }
 
@@ -768,6 +1161,9 @@
 
 RESULT eServiceMP3::isCurrentlySeekable()
 {
+#ifdef ENABLE_LIBEPLAYER3 // Hellmaster1024: 1 for skipping 3 for skipping anf fast forward
+	return 3;
+#else
 	int ret = 3; /* just assume that seeking and fast/slow winding are possible */
 
 	if (!m_gst_playbin)
@@ -776,6 +1172,7 @@
 		return 0;
 
 	return ret;
+#endif
 }
 
 RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
@@ -801,7 +1198,9 @@
 
 int eServiceMP3::getInfo(int w)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	const gchar *tag = 0;
+#endif
 
 	switch (w)
 	{
@@ -841,7 +1240,9 @@
 	case sTagKeywords:
 	case sTagChannelMode:
 	case sUser+12:
+#if not defined(__sh__)
 		return resIsString;
+#endif
 	case sTagTrackGain:
 	case sTagTrackPeak:
 	case sTagAlbumGain:
@@ -852,6 +1253,7 @@
 	case sTagPreviewImage:
 	case sTagAttachment:
 		return resIsPyObject;
+#ifndef ENABLE_LIBEPLAYER3
 	case sTagTrackNumber:
 		tag = GST_TAG_TRACK_NUMBER;
 		break;
@@ -885,22 +1287,26 @@
 	case sTagCRC:
 		tag = "has-crc";
 		break;
+#endif
 	default:
 		return resNA;
 	}
 
+#ifndef ENABLE_LIBEPLAYER3
 	if (!m_stream_tags || !tag)
 		return 0;
 
 	guint value;
 	if (gst_tag_list_get_uint(m_stream_tags, tag, &value))
 		return (int) value;
+#endif
 
 	return 0;
 }
 
 std::string eServiceMP3::getInfoString(int w)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	if ( !m_stream_tags && w < sUser && w > 26 )
 		return "";
 	const gchar *tag = 0;
@@ -1013,9 +1419,69 @@
 		g_free(value);
 		return res;
 	}
+#else
+	char * tag = NULL;
+	char * res_str = NULL;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+	default:
+		return "";
+	}
+
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+	free(tag);
+#endif
 	return "";
 }
 
+#ifndef ENABLE_LIBEPLAYER3
 PyObject *eServiceMP3::getInfoObject(int w)
 {
 	const gchar *tag = 0;
@@ -1094,6 +1560,7 @@
 
 	Py_RETURN_NONE;
 }
+#endif
 
 RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
 {
@@ -1126,13 +1593,16 @@
 
 int eServiceMP3::getCurrentTrack()
 {
+#ifndef ENABLE_LIBEPLAYER3
 	if (m_currentAudioStream == -1)
 		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
+#endif
 	return m_currentAudioStream;
 }
 
 RESULT eServiceMP3::selectTrack(unsigned int i)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	bool validposition = false;
 	pts_t ppos = 0;
 	if (getPlayPosition(ppos) >= 0)
@@ -1142,8 +1612,10 @@
 		if (ppos < 0)
 			ppos = 0;
 	}
+#endif
 
 	int ret = selectAudioStream(i);
+#ifndef ENABLE_LIBEPLAYER3
 	if (!ret)
 	{
 		if (validposition)
@@ -1152,12 +1624,14 @@
 			seekTo(ppos);
 		}
 	}
+#endif
 
 	return ret;
 }
 
 int eServiceMP3::selectAudioStream(int i)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	int current_audio;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
 	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
@@ -1168,6 +1642,16 @@
 		return 0;
 	}
 	return -1;
+#else
+	if (i != m_currentAudioStream)
+	{
+		if (player && player->playback)
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+#endif
 }
 
 int eServiceMP3::getCurrentChannel()
@@ -1185,6 +1669,7 @@
 {
  	if (i >= m_audioStreams.size())
 		return -2;
+#ifndef ENABLE_LIBEPLAYER3
 		info.m_description = m_audioStreams[i].codec;
 /*	if (m_audioStreams[i].type == atMPEG)
 		info.m_description = "MPEG";
@@ -1204,11 +1689,28 @@
 		info.m_description = "FLAC";
 	else
 		info.m_description = "???";*/
+#else
+	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+#endif
 	if (info.m_language.empty())
 		info.m_language = m_audioStreams[i].language_code;
 	return 0;
 }
 
+#ifndef ENABLE_LIBEPLAYER3
 subtype_t getSubtitleType(GstPad* pad, gchar *g_codec=NULL)
 {
 	subtype_t type = stUnknown;
@@ -1883,9 +2385,11 @@
 		}
 	}
 }
+#endif
 
 eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
 
+#ifndef ENABLE_LIBEPLAYER3
 void eServiceMP3::gstCBsubtitleAvail(GstElement *subsink, GstBuffer *buffer, gpointer user_data)
 {
 	eServiceMP3 *_this = (eServiceMP3*)user_data;
@@ -2021,9 +2525,30 @@
 		}
 	}
 }
+#else
+void eServiceMP3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceMP3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceMP3::%s <", __func__);
+}
+#endif
 
 void eServiceMP3::pushSubtitles()
 {
+#ifndef ENABLE_LIBEPLAYER3
 	while ( !m_subtitle_pages.empty() )
 	{
 		SubtitlePage &frontpage = m_subtitle_pages.front();
@@ -2075,6 +2600,7 @@
 			m_subtitle_pages.pop_front();
 		}
 	}
+#endif
 }
 
 RESULT eServiceMP3::enableSubtitles(eWidget *parent, ePyObject tuple)
@@ -2094,18 +2620,23 @@
 
 	if (m_currentSubtitleStream != pid)
 	{
+#ifndef ENABLE_LIBEPLAYER3
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", -1, NULL);
+#endif
 		m_subtitle_pages.clear();
 		m_prev_decoder_time = -1;
 		m_decoder_time_valid_state = 0;
+#ifndef ENABLE_LIBEPLAYER3
 		m_currentSubtitleStream = pid;
 		m_cachedSubtitleStream = m_currentSubtitleStream;
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
 
 		m_subtitle_widget = 0;
 		m_subtitle_widget = new eSubtitleWidget(parent);
 		m_subtitle_widget->resize(parent->size()); /* full size */
 
+#ifndef ENABLE_LIBEPLAYER3
 		eDebug ("eServiceMP3::switched to subtitle stream %i", m_currentSubtitleStream);
 
 #ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
@@ -2115,7 +2646,12 @@
 		 */
 		seekRelative(-1, 90000);
 #endif
+#endif
 	}
+#ifdef ENABLE_LIBEPLAYER3
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 
 	return 0;
 
@@ -2128,14 +2664,21 @@
 RESULT eServiceMP3::disableSubtitles(eWidget *parent)
 {
 	eDebug("eServiceMP3::disableSubtitles");
+#ifndef ENABLE_LIBEPLAYER3
 	m_currentSubtitleStream = -1;
 	m_cachedSubtitleStream = m_currentSubtitleStream;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
 	m_subtitle_pages.clear();
 	m_prev_decoder_time = -1;
 	m_decoder_time_valid_state = 0;
 	delete m_subtitle_widget;
 	m_subtitle_widget = 0;
+#ifdef ENABLE_LIBEPLAYER3
+	int pid = -1;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 	return 0;
 }
 
@@ -2207,7 +2750,9 @@
 int eServiceMP3::setBufferSize(int size)
 {
 	m_buffer_size = size;
+#ifndef ENABLE_LIBEPLAYER3
 	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
+#endif
 	return 0;
 }
 
@@ -2223,6 +2768,7 @@
 
 void eServiceMP3::setAC3Delay(int delay)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	ac3_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -2252,10 +2798,12 @@
 			eTSMPEGDecoder::setHwAC3Delay(config_delay_int);
 		}
 	}
+#endif
 }
 
 void eServiceMP3::setPCMDelay(int delay)
 {
+#ifndef ENABLE_LIBEPLAYER3
 	pcm_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -2285,4 +2833,5 @@
 			eTSMPEGDecoder::setHwPCMDelay(config_delay_int);
 		}
 	}
+#endif
 }
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/lib/service/servicemp3.h enigma2-nightly/lib/service/servicemp3.h
--- enigma2-nightly.org/lib/service/servicemp3.h	2013-01-31 12:39:33.692182809 +0100
+++ enigma2-nightly/lib/service/servicemp3.h	2013-01-31 12:39:34.000182823 +0100
@@ -6,7 +6,18 @@
 #include <lib/dvb/pmt.h>
 #include <lib/dvb/subtitle.h>
 #include <lib/dvb/teletext.h>
+#ifndef ENABLE_LIBEPLAYER3
 #include <gst/gst.h>
+#else
+#include <common.h>
+#include <subtitle.h>
+#define gint int
+#define gint64 int64_t
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t	ManagerHandler;
+#endif
 /* for subtitles */
 #include <lib/gui/esubtitle.h>
 
@@ -45,7 +56,9 @@
 	PyObject* getInfoObject(const eServiceReference &ref, int w);
 };
 
+#ifndef ENABLE_LIBEPLAYER3
 typedef struct _GstElement GstElement;
+#endif
 
 typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
 typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
@@ -103,7 +116,9 @@
 	RESULT getName(std::string &name);
 	int getInfo(int w);
 	std::string getInfoString(int w);
+#ifndef ENABLE_LIBEPLAYER3
 	PyObject *getInfoObject(int w);
+#endif
 
 		// iAudioTrackSelection	
 	int getNumberOfTracks();
@@ -132,6 +147,7 @@
 	void setAC3Delay(int);
 	void setPCMDelay(int);
 
+#ifndef ENABLE_LIBEPLAYER3
 	struct audioStream
 	{
 		GstPad* pad;
@@ -164,6 +180,38 @@
 		{
 		}
 	};
+#else
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+#endif
 	struct bufferInfo
 	{
 		gint bufferPercent;

@@ -208,6 +262,7 @@
 		stIdle, stRunning, stStopped,
 	};
 	int m_state;
+#ifndef ENABLE_LIBEPLAYER3
 	GstElement *m_gst_playbin, *audioSink, *videoSink;
 	GstTagList *m_stream_tags;
 

@@ -268,16 +339,22 @@
 	int m_decoder_time_valid_state;
 
 	void pushSubtitles();
+#ifndef ENABLE_LIBEPLAYER3
 	void pullSubtitle(GstBuffer *buffer);
+#endif
 	void sourceTimeout();
 	sourceStream m_sourceinfo;
+#ifndef ENABLE_LIBEPLAYER3
 	gulong m_subs_to_pull_handler_id;
+#endif
 
 	RESULT seekToImpl(pts_t to);
 
 	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
 	std::string m_useragent;
+#ifndef ENABLE_LIBEPLAYER3
 	RESULT trickSeek(gdouble ratio);
+#endif
 };
 
 #endif
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/m4/ax_python_devel.m4 enigma2-nightly/m4/ax_python_devel.m4
--- enigma2-nightly.org/m4/ax_python_devel.m4	2013-01-31 12:39:33.692182809 +0100
+++ enigma2-nightly/m4/ax_python_devel.m4	2013-01-31 12:39:34.000182823 +0100
@@ -154,7 +154,7 @@
 		python_path=`$PYTHON -c "import distutils.sysconfig; \
 			print (distutils.sysconfig.get_python_inc ());"`
 		if test -n "${python_path}"; then
-			python_path="-I$python_path"
+			python_path="-I$PY_PATH/include/python$PYTHON_VERSION"
 		fi
 		PYTHON_CPPFLAGS=$python_path
 	fi
@@ -235,7 +235,8 @@
 			  "from distutils.sysconfig import get_python_lib as f; \
 			  import os; \
 			  print (os.path.join(f(plat_specific=1, standard_lib=1), 'config'));"`
-			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
+			PYTHON_LDFLAGS="-L$PY_PATH/include/python$PYTHON_VERSION -lpython$ac_python_version"
+#			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
 		fi
 
 		if test -z "PYTHON_LDFLAGS"; then
@@ -253,8 +254,9 @@
 	#
 	AC_MSG_CHECKING([for Python site-packages path])
 	if test -z "$PYTHON_SITE_PKG"; then
-		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
-			print (distutils.sysconfig.get_python_lib(0,0));"`
+		PYTHON_SITE_PKG="$PY_PATH/lib/python$PYTHON_VERSION/site-packages"
+#		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
+#			print (distutils.sysconfig.get_python_lib(0,0));"`
 	fi
 	AC_MSG_RESULT([$PYTHON_SITE_PKG])
 	AC_SUBST([PYTHON_SITE_PKG])

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/main/enigma.cpp enigma2-nightly/main/enigma.cpp
--- enigma2-nightly.org/main/enigma.cpp	2013-01-31 12:39:33.692182809 +0100
+++ enigma2-nightly/main/enigma.cpp	2013-01-31 12:39:34.000182823 +0100
@@ -28,10 +28,15 @@
 #include <lib/python/connections.h>
 #include <lib/python/python.h>
 
+#if defined(__sh__) // vfd class
+#include <lib/driver/vfd.h>
+#endif
 #include "bsod.h"
 #include "version_info.h"
 
+#ifndef ENABLE_LIBEPLAYER3
 #include <gst/gst.h>
+#endif
 
 #ifdef OBJECT_DEBUG
 int object_total_remaining;
@@ -133,7 +138,9 @@
 	atexit(object_dump);
 #endif
 
+#ifndef ENABLE_LIBEPLAYER3
 	gst_init(&argc, &argv);
+#endif
 
 	// set pythonpath if unset
 	setenv("PYTHONPATH", eEnv::resolve("${libdir}/enigma2/python").c_str(), 0);
@@ -166,7 +173,11 @@
 	eWidgetDesktop dsk_lcd(my_lcd_dc->size());
 
 	dsk.setStyleID(0);
+#ifdef HAVE_GRAPHLCD
+	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 320 ? 1 : 2);
+#else
 	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 96 ? 2 : 1);
+#endif
 
 /*	if (double_buffer)
 	{
@@ -220,6 +231,12 @@
 	gRC::getInstance()->setSpinnerDC(my_dc);
 
 	eRCInput::getInstance()->keyEvent.connect(slot(keyEvent));
+
+#if defined(__sh__) // initialise the vfd class
+	evfd * vfd = new evfd;
+	vfd->init();
+	delete vfd;
+#endif
 	
 	printf("executing main\n");
 	
diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/main/Makefile.am enigma2-nightly/main/Makefile.am
--- enigma2-nightly.org/main/Makefile.am	2013-01-31 12:39:33.692182809 +0100
+++ enigma2-nightly/main/Makefile.am	2013-01-31 12:39:34.000182823 +0100
@@ -9,6 +9,8 @@
 
 bin_PROGRAMS = enigma2
 
+installdir = $(targetprefix)/usr/local/bin
+
 enigma2_SOURCES = \
 	bsod.cpp \
 	bsod.h \

diff -Naur '--exclude-from=diff-ignore' enigma2-nightly.org/mytest.py enigma2-nightly/mytest.py
--- enigma2-nightly.org/mytest.py	2013-01-31 12:39:33.692182809 +0100
+++ enigma2-nightly/mytest.py	2013-01-31 12:39:34.000182823 +0100
@@ -302,6 +302,10 @@
 
 		self.pushCurrent()
 		dlg = self.current_dialog = self.instantiateDialog(screen, *arguments, **kwargs)
+
+		if dlg is None:
+			return
+
 		dlg.isTmp = True
 		dlg.callback = None
 		self.execBegin()
@@ -511,10 +515,10 @@
 	if wakeupList:
 		from time import strftime
 		startTime = wakeupList[0]
-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
+		if (startTime[0] - nowTime) < 330: # no time to switch box back on
 			wptime = nowTime + 30  # so switch back on in 30 seconds
 		else:
-			wptime = startTime[0] - 240
+			wptime = startTime[0] - 300
 		if not config.misc.useTransponderTime.value:
 			print "dvb time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime))
 			setRTCtime(nowTime)
